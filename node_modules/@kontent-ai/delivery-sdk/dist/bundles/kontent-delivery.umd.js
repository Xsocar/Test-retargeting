(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("kontentDelivery", [], factory);
	else if(typeof exports === 'object')
		exports["kontentDelivery"] = factory();
	else
		root["kontentDelivery"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@kontent-ai/core-sdk/dist/es6/helpers/enum.helper.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@kontent-ai/core-sdk/dist/es6/helpers/enum.helper.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EnumHelper": () => (/* binding */ EnumHelper),
/* harmony export */   "enumHelper": () => (/* binding */ enumHelper)
/* harmony export */ });
class EnumHelper {
    getAllNames(T) {
        const enumNames = [];
        for (const key in T) {
            if (T.hasOwnProperty(key)) {
                enumNames.push(key);
            }
        }
        return enumNames;
    }
    getAllValues(T) {
        const allEnumValues = Object.keys(T).map(key => T[key]);
        return allEnumValues;
    }
    getEnumFromValue(T, value) {
        try {
            if (!value) {
                return undefined;
            }
            // we can map back from index number directly
            if (this.isNumeric(value)) {
                return T[value];
            }
            // for strings, we need to compare each value separately
            const allEnumValues = this.getAllValues(T);
            const result = allEnumValues.find(m => m.toLowerCase() === value.toString().toLowerCase());
            if (!result) {
                return undefined;
            }
            return result;
        }
        catch (err) {
            return undefined;
        }
    }
    getEnumFromName(T, name) {
        const allNames = this.getAllNames(T);
        for (const enumName of allNames) {
            if (enumName.toLowerCase() === name.toLowerCase()) {
                return T[enumName];
            }
        }
        return undefined;
    }
    isNumeric(value) {
        return !isNaN(parseFloat(value)) && isFinite(value);
    }
}
const enumHelper = new EnumHelper();
//# sourceMappingURL=enum.helper.js.map

/***/ }),

/***/ "./node_modules/@kontent-ai/core-sdk/dist/es6/helpers/header.helper.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@kontent-ai/core-sdk/dist/es6/helpers/header.helper.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HeaderHelper": () => (/* binding */ HeaderHelper),
/* harmony export */   "headerHelper": () => (/* binding */ headerHelper)
/* harmony export */ });
class HeaderHelper {
    constructor() {
        /**
        * Header name for SDK usage
        */
        this.sdkVersionHeader = 'X-KC-SDKID';
    }
    /**
    * Header identifying SDK type & version for internal purposes of Kontent.ai
    */
    getSdkIdHeader(info) {
        return {
            header: this.sdkVersionHeader,
            value: `${info.host};${info.name};${info.version}`
        };
    }
}
const headerHelper = new HeaderHelper();
//# sourceMappingURL=header.helper.js.map

/***/ }),

/***/ "./node_modules/@kontent-ai/core-sdk/dist/es6/helpers/headers-helper.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@kontent-ai/core-sdk/dist/es6/helpers/headers-helper.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "extractHeadersFromAxiosResponse": () => (/* binding */ extractHeadersFromAxiosResponse)
/* harmony export */ });
function extractHeadersFromAxiosResponse(response) {
    const headers = [];
    for (const headerKey of Object.keys(response.headers)) {
        headers.push({
            header: headerKey,
            value: response.headers[headerKey]
        });
    }
    return headers;
}
//# sourceMappingURL=headers-helper.js.map

/***/ }),

/***/ "./node_modules/@kontent-ai/core-sdk/dist/es6/helpers/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@kontent-ai/core-sdk/dist/es6/helpers/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EnumHelper": () => (/* reexport safe */ _enum_helper__WEBPACK_IMPORTED_MODULE_2__.EnumHelper),
/* harmony export */   "HeaderHelper": () => (/* reexport safe */ _header_helper__WEBPACK_IMPORTED_MODULE_1__.HeaderHelper),
/* harmony export */   "RetryHelper": () => (/* reexport safe */ _retry_helper__WEBPACK_IMPORTED_MODULE_3__.RetryHelper),
/* harmony export */   "UrlHelper": () => (/* reexport safe */ _url_helper__WEBPACK_IMPORTED_MODULE_0__.UrlHelper),
/* harmony export */   "enumHelper": () => (/* reexport safe */ _enum_helper__WEBPACK_IMPORTED_MODULE_2__.enumHelper),
/* harmony export */   "extractHeadersFromAxiosResponse": () => (/* reexport safe */ _headers_helper__WEBPACK_IMPORTED_MODULE_4__.extractHeadersFromAxiosResponse),
/* harmony export */   "headerHelper": () => (/* reexport safe */ _header_helper__WEBPACK_IMPORTED_MODULE_1__.headerHelper),
/* harmony export */   "retryHelper": () => (/* reexport safe */ _retry_helper__WEBPACK_IMPORTED_MODULE_3__.retryHelper),
/* harmony export */   "urlHelper": () => (/* reexport safe */ _url_helper__WEBPACK_IMPORTED_MODULE_0__.urlHelper)
/* harmony export */ });
/* harmony import */ var _url_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./url.helper */ "./node_modules/@kontent-ai/core-sdk/dist/es6/helpers/url.helper.js");
/* harmony import */ var _header_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./header.helper */ "./node_modules/@kontent-ai/core-sdk/dist/es6/helpers/header.helper.js");
/* harmony import */ var _enum_helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./enum.helper */ "./node_modules/@kontent-ai/core-sdk/dist/es6/helpers/enum.helper.js");
/* harmony import */ var _retry_helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./retry-helper */ "./node_modules/@kontent-ai/core-sdk/dist/es6/helpers/retry-helper.js");
/* harmony import */ var _headers_helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./headers-helper */ "./node_modules/@kontent-ai/core-sdk/dist/es6/helpers/headers-helper.js");





//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@kontent-ai/core-sdk/dist/es6/helpers/retry-helper.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@kontent-ai/core-sdk/dist/es6/helpers/retry-helper.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RetryHelper": () => (/* binding */ RetryHelper),
/* harmony export */   "retryHelper": () => (/* binding */ retryHelper)
/* harmony export */ });
/* harmony import */ var _headers_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./headers-helper */ "./node_modules/@kontent-ai/core-sdk/dist/es6/helpers/headers-helper.js");

class RetryHelper {
    constructor() {
        this.requestCancelledMessagePrefix = 'Request cancelled';
        this.retryAfterHeaderName = 'Retry-After';
        this.defaultRetryStatusCodes = [408, 429, 500, 502, 503, 504];
        this.defaultRetryStrategy = {
            addJitter: true,
            deltaBackoffMs: 1000,
            maxAttempts: 5,
            canRetryError: (error) => this.canRetryErrorDefault(error)
        };
    }
    getRetryErrorResult(data) {
        var _a, _b, _c;
        if (data.error && data.error.message) {
            if (data.error.message.startsWith(this.requestCancelledMessagePrefix)) {
                // request was cancelled by user, do not retry it
                return {
                    canRetry: false,
                    retryInMs: 0,
                    maxRetries: 0
                };
            }
        }
        const canRetryError = data.retryStrategy.canRetryError
            ? data.retryStrategy.canRetryError(data.error)
            : this.defaultRetryStrategy.canRetryError(data.error);
        if (!canRetryError) {
            // request cannot be retried
            return {
                canRetry: false,
                retryInMs: 0,
                maxRetries: 0
            };
        }
        const maxRetries = ((_a = data.retryStrategy.maxAttempts) !== null && _a !== void 0 ? _a : this.defaultRetryStrategy.maxAttempts);
        const maxRetriesReached = data.retryAttempt >= maxRetries;
        if (maxRetriesReached) {
            // request cannot be retried anymore due to maximum attempts
            return {
                canRetry: false,
                retryInMs: 0,
                maxRetries: maxRetries
            };
        }
        // get wait time
        const retryResult = this.tryGetRetryAfterInMsFromError(data.error);
        if (retryResult) {
            // retry after header was provided
            return {
                canRetry: true,
                retryInMs: retryResult,
                maxRetries: maxRetries
            };
        }
        // wait time was not provided in header
        const waitTimeMs = this.getNextWaitTimeMs((_b = data.retryStrategy.addJitter) !== null && _b !== void 0 ? _b : this.defaultRetryStrategy.addJitter, (_c = data.retryStrategy.deltaBackoffMs) !== null && _c !== void 0 ? _c : this.defaultRetryStrategy.deltaBackoffMs, data.retryAttempt);
        return {
            canRetry: true,
            retryInMs: waitTimeMs,
            maxRetries: maxRetries
        };
    }
    getRetryStrategyFromStrategyOptions(retryOptions) {
        if (!retryOptions) {
            return this.defaultRetryStrategy;
        }
        return retryOptions;
    }
    canRetryInTime(startTime, maxCumulativeWaitTimeMs) {
        const start = startTime.getTime();
        const now = new Date().getTime();
        const differenceInMs = now - start;
        return {
            canRetry: differenceInMs < maxCumulativeWaitTimeMs,
            differenceInMs: differenceInMs
        };
    }
    getNextWaitTimeMs(addJitter, deltaBackoffMs, retryAttempts) {
        if (!addJitter) {
            return deltaBackoffMs * Math.pow(2, retryAttempts);
        }
        const from = 0.8 * deltaBackoffMs;
        const to = 1.2 * deltaBackoffMs * Math.pow(2, retryAttempts);
        return this.randomNumberFromInterval(from, to);
    }
    canRetryErrorDefault(error) {
        const axiosError = this.tryGetAxiosError(error);
        if (!axiosError) {
            // by default non-axios errors are not retried
            return false;
        }
        const statusCode = this.getStatusCodeFromError(error);
        const canRetryStatusCode = this.canRetryStatusCode(statusCode, this.defaultRetryStatusCodes);
        if (canRetryStatusCode) {
            return true;
        }
        return false;
    }
    tryGetRetryAfterInMsFromError(error) {
        const axiosError = this.tryGetAxiosError(error);
        if (!axiosError || !axiosError.response) {
            return undefined;
        }
        const headers = (0,_headers_helper__WEBPACK_IMPORTED_MODULE_0__.extractHeadersFromAxiosResponse)(axiosError.response);
        const retryValueHeader = headers.find((m) => m.header.toLowerCase() === this.retryAfterHeaderName.toLowerCase());
        if (!retryValueHeader) {
            return undefined;
        }
        const retryInSeconds = +retryValueHeader.value;
        return retryInSeconds * 1000;
    }
    canRetryStatusCode(statusCode, useRetryForResponseCodes) {
        return useRetryForResponseCodes.includes(statusCode);
    }
    getStatusCodeFromError(error) {
        const axiosError = this.tryGetAxiosError(error);
        if (!axiosError || !axiosError.response) {
            return 0;
        }
        return axiosError.response.status;
    }
    tryGetAxiosError(error) {
        if (!error) {
            return undefined;
        }
        if (error.isAxiosError) {
            return error;
        }
        const originalError = error.originalError;
        if (originalError && originalError.isAxiosError) {
            return originalError;
        }
        return undefined;
    }
    /**
     * min and max included
     */
    randomNumberFromInterval(min, max) {
        return Math.floor(Math.random() * (max - min + 1) + min);
    }
}
const retryHelper = new RetryHelper();
//# sourceMappingURL=retry-helper.js.map

/***/ }),

/***/ "./node_modules/@kontent-ai/core-sdk/dist/es6/helpers/url.helper.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@kontent-ai/core-sdk/dist/es6/helpers/url.helper.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UrlHelper": () => (/* binding */ UrlHelper),
/* harmony export */   "urlHelper": () => (/* binding */ urlHelper)
/* harmony export */ });
class UrlHelper {
    /**
   * Adds query parameters to given url
   * @param url Url to which options will be added
   * @param options Query parameters to add
   */
    addOptionsToUrl(url, options) {
        if (options) {
            options.forEach(filter => {
                if (url.indexOf('?') > -1) {
                    url += '&';
                }
                else {
                    url += '?';
                }
                url += filter.getParam();
            });
        }
        return url;
    }
}
const urlHelper = new UrlHelper();
//# sourceMappingURL=url.helper.js.map

/***/ }),

/***/ "./node_modules/@kontent-ai/core-sdk/dist/es6/http/http.debugger.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@kontent-ai/core-sdk/dist/es6/http/http.debugger.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HttpDebugger": () => (/* binding */ HttpDebugger),
/* harmony export */   "httpDebugger": () => (/* binding */ httpDebugger)
/* harmony export */ });
class HttpDebugger {
    /*
    Called when http request is started
    */
    debugStartHttpRequest() {
    }
    /*
    Called when http request is resolved
    */
    debugSuccessHttpRequest() {
    }
    /*
    Called when http request is being retried
    */
    debugRetryHttpRequest() {
    }
}
const httpDebugger = new HttpDebugger();
//# sourceMappingURL=http.debugger.js.map

/***/ }),

/***/ "./node_modules/@kontent-ai/core-sdk/dist/es6/http/http.functions.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@kontent-ai/core-sdk/dist/es6/http/http.functions.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createCancelToken": () => (/* binding */ createCancelToken),
/* harmony export */   "deleteWithRetryAsync": () => (/* binding */ deleteWithRetryAsync),
/* harmony export */   "getWithRetryAsync": () => (/* binding */ getWithRetryAsync),
/* harmony export */   "patchWithRetryAsync": () => (/* binding */ patchWithRetryAsync),
/* harmony export */   "postWithRetryAsync": () => (/* binding */ postWithRetryAsync),
/* harmony export */   "putWithRetryAsync": () => (/* binding */ putWithRetryAsync)
/* harmony export */ });
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _helpers_headers_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/headers-helper */ "./node_modules/@kontent-ai/core-sdk/dist/es6/helpers/headers-helper.js");
/* harmony import */ var _http_debugger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./http.debugger */ "./node_modules/@kontent-ai/core-sdk/dist/es6/http/http.debugger.js");
/* harmony import */ var _helpers_retry_helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/retry-helper */ "./node_modules/@kontent-ai/core-sdk/dist/es6/helpers/retry-helper.js");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};




function getWithRetryAsync(instance, call, functionsConfig, options) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const retryStrategyOptions = (_a = options === null || options === void 0 ? void 0 : options.retryStrategy) !== null && _a !== void 0 ? _a : _helpers_retry_helper__WEBPACK_IMPORTED_MODULE_3__.retryHelper.defaultRetryStrategy;
        return yield runWithRetryAsync({
            retryAttempt: 0,
            url: call.url,
            retryStrategy: retryStrategyOptions,
            functionsConfig: functionsConfig,
            call: (retryAttempt) => __awaiter(this, void 0, void 0, function* () {
                var _b, _c;
                _http_debugger__WEBPACK_IMPORTED_MODULE_2__.httpDebugger.debugStartHttpRequest();
                const axiosResponse = yield instance.get(call.url, {
                    headers: getHeadersJson((_b = options === null || options === void 0 ? void 0 : options.headers) !== null && _b !== void 0 ? _b : [], false),
                    responseType: options === null || options === void 0 ? void 0 : options.responseType,
                    cancelToken: (_c = options === null || options === void 0 ? void 0 : options.cancelToken) === null || _c === void 0 ? void 0 : _c.token
                });
                const response = {
                    data: axiosResponse.data,
                    rawResponse: axiosResponse,
                    headers: (0,_helpers_headers_helper__WEBPACK_IMPORTED_MODULE_1__.extractHeadersFromAxiosResponse)(axiosResponse),
                    status: axiosResponse.status,
                    retryStrategy: {
                        options: retryStrategyOptions,
                        retryAttempts: retryAttempt
                    }
                };
                _http_debugger__WEBPACK_IMPORTED_MODULE_2__.httpDebugger.debugSuccessHttpRequest();
                return response;
            })
        });
    });
}
function postWithRetryAsync(instance, call, functionsConfig, options) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const retryStrategyOptions = (_a = options === null || options === void 0 ? void 0 : options.retryStrategy) !== null && _a !== void 0 ? _a : _helpers_retry_helper__WEBPACK_IMPORTED_MODULE_3__.retryHelper.defaultRetryStrategy;
        return yield runWithRetryAsync({
            retryAttempt: 0,
            url: call.url,
            retryStrategy: retryStrategyOptions,
            functionsConfig: functionsConfig,
            call: (retryAttempt) => __awaiter(this, void 0, void 0, function* () {
                var _b, _c;
                _http_debugger__WEBPACK_IMPORTED_MODULE_2__.httpDebugger.debugStartHttpRequest();
                const axiosResponse = yield instance.post(call.url, call.body, {
                    headers: getHeadersJson((_b = options === null || options === void 0 ? void 0 : options.headers) !== null && _b !== void 0 ? _b : [], false),
                    responseType: options === null || options === void 0 ? void 0 : options.responseType,
                    // required for uploading large files
                    // https://github.com/axios/axios/issues/1362
                    maxContentLength: 'Infinity',
                    maxBodyLength: 'Infinity',
                    cancelToken: (_c = options === null || options === void 0 ? void 0 : options.cancelToken) === null || _c === void 0 ? void 0 : _c.token
                });
                const response = {
                    data: axiosResponse.data,
                    rawResponse: axiosResponse,
                    headers: (0,_helpers_headers_helper__WEBPACK_IMPORTED_MODULE_1__.extractHeadersFromAxiosResponse)(axiosResponse),
                    status: axiosResponse.status,
                    retryStrategy: {
                        options: retryStrategyOptions,
                        retryAttempts: retryAttempt
                    }
                };
                _http_debugger__WEBPACK_IMPORTED_MODULE_2__.httpDebugger.debugSuccessHttpRequest();
                return response;
            })
        });
    });
}
function putWithRetryAsync(instance, call, functionsConfig, options) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const retryStrategyOptions = (_a = options === null || options === void 0 ? void 0 : options.retryStrategy) !== null && _a !== void 0 ? _a : _helpers_retry_helper__WEBPACK_IMPORTED_MODULE_3__.retryHelper.defaultRetryStrategy;
        return yield runWithRetryAsync({
            retryAttempt: 0,
            url: call.url,
            retryStrategy: retryStrategyOptions,
            functionsConfig: functionsConfig,
            call: (retryAttempt) => __awaiter(this, void 0, void 0, function* () {
                var _b, _c;
                _http_debugger__WEBPACK_IMPORTED_MODULE_2__.httpDebugger.debugStartHttpRequest();
                const axiosResponse = yield instance.put(call.url, call.body, {
                    headers: getHeadersJson((_b = options === null || options === void 0 ? void 0 : options.headers) !== null && _b !== void 0 ? _b : [], false),
                    responseType: options === null || options === void 0 ? void 0 : options.responseType,
                    // required for uploading large files
                    // https://github.com/axios/axios/issues/1362
                    maxContentLength: 'Infinity',
                    maxBodyLength: 'Infinity',
                    cancelToken: (_c = options === null || options === void 0 ? void 0 : options.cancelToken) === null || _c === void 0 ? void 0 : _c.token
                });
                const response = {
                    data: axiosResponse.data,
                    rawResponse: axiosResponse,
                    headers: (0,_helpers_headers_helper__WEBPACK_IMPORTED_MODULE_1__.extractHeadersFromAxiosResponse)(axiosResponse),
                    status: axiosResponse.status,
                    retryStrategy: {
                        options: retryStrategyOptions,
                        retryAttempts: retryAttempt
                    }
                };
                _http_debugger__WEBPACK_IMPORTED_MODULE_2__.httpDebugger.debugSuccessHttpRequest();
                return response;
            })
        });
    });
}
function patchWithRetryAsync(instance, call, functionsConfig, options) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const retryStrategyOptions = (_a = options === null || options === void 0 ? void 0 : options.retryStrategy) !== null && _a !== void 0 ? _a : _helpers_retry_helper__WEBPACK_IMPORTED_MODULE_3__.retryHelper.defaultRetryStrategy;
        return yield runWithRetryAsync({
            retryAttempt: 0,
            url: call.url,
            retryStrategy: retryStrategyOptions,
            functionsConfig: functionsConfig,
            call: (retryAttempt) => __awaiter(this, void 0, void 0, function* () {
                var _b, _c;
                _http_debugger__WEBPACK_IMPORTED_MODULE_2__.httpDebugger.debugStartHttpRequest();
                const axiosResponse = yield instance.patch(call.url, call.body, {
                    headers: getHeadersJson((_b = options === null || options === void 0 ? void 0 : options.headers) !== null && _b !== void 0 ? _b : [], false),
                    responseType: options === null || options === void 0 ? void 0 : options.responseType,
                    // required for uploading large files
                    // https://github.com/axios/axios/issues/1362
                    maxContentLength: 'Infinity',
                    maxBodyLength: 'Infinity',
                    cancelToken: (_c = options === null || options === void 0 ? void 0 : options.cancelToken) === null || _c === void 0 ? void 0 : _c.token
                });
                const response = {
                    data: axiosResponse.data,
                    rawResponse: axiosResponse,
                    headers: (0,_helpers_headers_helper__WEBPACK_IMPORTED_MODULE_1__.extractHeadersFromAxiosResponse)(axiosResponse),
                    status: axiosResponse.status,
                    retryStrategy: {
                        options: retryStrategyOptions,
                        retryAttempts: retryAttempt
                    }
                };
                _http_debugger__WEBPACK_IMPORTED_MODULE_2__.httpDebugger.debugSuccessHttpRequest();
                return response;
            })
        });
    });
}
function deleteWithRetryAsync(instance, call, functionsConfig, options) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const retryStrategyOptions = (_a = options === null || options === void 0 ? void 0 : options.retryStrategy) !== null && _a !== void 0 ? _a : _helpers_retry_helper__WEBPACK_IMPORTED_MODULE_3__.retryHelper.defaultRetryStrategy;
        return yield runWithRetryAsync({
            retryAttempt: 0,
            url: call.url,
            retryStrategy: retryStrategyOptions,
            functionsConfig: functionsConfig,
            call: (retryAttempt) => __awaiter(this, void 0, void 0, function* () {
                var _b, _c;
                _http_debugger__WEBPACK_IMPORTED_MODULE_2__.httpDebugger.debugStartHttpRequest();
                const axiosResponse = yield instance.delete(call.url, {
                    headers: getHeadersJson((_b = options === null || options === void 0 ? void 0 : options.headers) !== null && _b !== void 0 ? _b : [], false),
                    responseType: options === null || options === void 0 ? void 0 : options.responseType,
                    // required for uploading large files
                    // https://github.com/axios/axios/issues/1362
                    maxContentLength: 'Infinity',
                    maxBodyLength: 'Infinity',
                    cancelToken: (_c = options === null || options === void 0 ? void 0 : options.cancelToken) === null || _c === void 0 ? void 0 : _c.token
                });
                const response = {
                    data: axiosResponse.data,
                    rawResponse: axiosResponse,
                    headers: (0,_helpers_headers_helper__WEBPACK_IMPORTED_MODULE_1__.extractHeadersFromAxiosResponse)(axiosResponse),
                    status: axiosResponse.status,
                    retryStrategy: {
                        options: retryStrategyOptions,
                        retryAttempts: retryAttempt
                    }
                };
                _http_debugger__WEBPACK_IMPORTED_MODULE_2__.httpDebugger.debugSuccessHttpRequest();
                return response;
            })
        });
    });
}
function createCancelToken() {
    let canceler;
    const token = new (axios__WEBPACK_IMPORTED_MODULE_0___default().CancelToken)((c) => {
        // An executor function receives a cancel function as a parameter
        canceler = c;
    });
    return {
        cancel: (cancelMessage) => canceler(`${_helpers_retry_helper__WEBPACK_IMPORTED_MODULE_3__.retryHelper.requestCancelledMessagePrefix}: ${cancelMessage !== null && cancelMessage !== void 0 ? cancelMessage : 'User cancel'}`),
        token: token
    };
}
function runWithRetryAsync(data) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            return yield data.call(data.retryAttempt);
        }
        catch (error) {
            const retryResult = _helpers_retry_helper__WEBPACK_IMPORTED_MODULE_3__.retryHelper.getRetryErrorResult({
                error: error,
                retryAttempt: data.retryAttempt,
                retryStrategy: data.retryStrategy
            });
            if (retryResult.canRetry) {
                _http_debugger__WEBPACK_IMPORTED_MODULE_2__.httpDebugger.debugRetryHttpRequest();
                // wait time before retrying
                yield new Promise((resolve) => setTimeout(resolve, retryResult.retryInMs));
                // retry request
                console.warn(`Retry attempt '${data.retryAttempt + 1}' from a maximum of '${retryResult.maxRetries}' retries. Request url: '${data.url}'`);
                return yield runWithRetryAsync({
                    call: data.call,
                    retryStrategy: data.retryStrategy,
                    retryAttempt: data.retryAttempt + 1,
                    url: data.url,
                    functionsConfig: data.functionsConfig
                });
            }
            if (data.functionsConfig.logErrorsToConsole) {
                console.error(`Executing '${data.url}' failed. Request was retried '${data.retryAttempt}' times. `, error);
            }
            throw error;
        }
    });
}
function getHeadersJson(headers, addContentTypeHeader) {
    const headerJson = {};
    headers.forEach((header) => {
        headerJson[header.header] = header.value;
    });
    if (addContentTypeHeader) {
        // add default content type header if not present
        const contentTypeHeader = headers.find((m) => m.header.toLowerCase() === 'Content-Type'.toLowerCase());
        if (!contentTypeHeader) {
            headerJson['Content-Type'] = 'application/json';
        }
    }
    return headerJson;
}
//# sourceMappingURL=http.functions.js.map

/***/ }),

/***/ "./node_modules/@kontent-ai/core-sdk/dist/es6/http/http.models.js":
/*!************************************************************************!*\
  !*** ./node_modules/@kontent-ai/core-sdk/dist/es6/http/http.models.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=http.models.js.map

/***/ }),

/***/ "./node_modules/@kontent-ai/core-sdk/dist/es6/http/http.service.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@kontent-ai/core-sdk/dist/es6/http/http.service.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HttpService": () => (/* binding */ HttpService)
/* harmony export */ });
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _http_functions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./http.functions */ "./node_modules/@kontent-ai/core-sdk/dist/es6/http/http.functions.js");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


class HttpService {
    constructor(opts) {
        this.opts = opts;
        this.axiosInstance = axios__WEBPACK_IMPORTED_MODULE_0___default().create(opts === null || opts === void 0 ? void 0 : opts.axiosRequestConfig);
        this.functionsConfig = this.getFunctionsConfig();
    }
    getAsync(call, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield _http_functions__WEBPACK_IMPORTED_MODULE_1__.getWithRetryAsync(this.axiosInstance, call, this.functionsConfig, options);
        });
    }
    postAsync(call, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield _http_functions__WEBPACK_IMPORTED_MODULE_1__.postWithRetryAsync(this.axiosInstance, call, this.functionsConfig, options);
        });
    }
    putAsync(call, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield _http_functions__WEBPACK_IMPORTED_MODULE_1__.putWithRetryAsync(this.axiosInstance, call, this.functionsConfig, options);
        });
    }
    patchAsync(call, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield _http_functions__WEBPACK_IMPORTED_MODULE_1__.patchWithRetryAsync(this.axiosInstance, call, this.functionsConfig, options);
        });
    }
    deleteAsync(call, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield _http_functions__WEBPACK_IMPORTED_MODULE_1__.deleteWithRetryAsync(this.axiosInstance, call, this.functionsConfig, options);
        });
    }
    createCancelToken() {
        return _http_functions__WEBPACK_IMPORTED_MODULE_1__.createCancelToken();
    }
    getFunctionsConfig() {
        var _a, _b;
        return {
            logErrorsToConsole: (_b = (_a = this.opts) === null || _a === void 0 ? void 0 : _a.logErrorsToConsole) !== null && _b !== void 0 ? _b : true
        };
    }
}
//# sourceMappingURL=http.service.js.map

/***/ }),

/***/ "./node_modules/@kontent-ai/core-sdk/dist/es6/http/ihttp.service.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@kontent-ai/core-sdk/dist/es6/http/ihttp.service.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=ihttp.service.js.map

/***/ }),

/***/ "./node_modules/@kontent-ai/core-sdk/dist/es6/http/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@kontent-ai/core-sdk/dist/es6/http/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HttpDebugger": () => (/* reexport safe */ _http_debugger__WEBPACK_IMPORTED_MODULE_4__.HttpDebugger),
/* harmony export */   "HttpService": () => (/* reexport safe */ _http_service__WEBPACK_IMPORTED_MODULE_1__.HttpService),
/* harmony export */   "TestHttpService": () => (/* reexport safe */ _test_http_service__WEBPACK_IMPORTED_MODULE_5__.TestHttpService),
/* harmony export */   "createCancelToken": () => (/* reexport safe */ _http_functions__WEBPACK_IMPORTED_MODULE_3__.createCancelToken),
/* harmony export */   "deleteWithRetryAsync": () => (/* reexport safe */ _http_functions__WEBPACK_IMPORTED_MODULE_3__.deleteWithRetryAsync),
/* harmony export */   "getWithRetryAsync": () => (/* reexport safe */ _http_functions__WEBPACK_IMPORTED_MODULE_3__.getWithRetryAsync),
/* harmony export */   "httpDebugger": () => (/* reexport safe */ _http_debugger__WEBPACK_IMPORTED_MODULE_4__.httpDebugger),
/* harmony export */   "patchWithRetryAsync": () => (/* reexport safe */ _http_functions__WEBPACK_IMPORTED_MODULE_3__.patchWithRetryAsync),
/* harmony export */   "postWithRetryAsync": () => (/* reexport safe */ _http_functions__WEBPACK_IMPORTED_MODULE_3__.postWithRetryAsync),
/* harmony export */   "putWithRetryAsync": () => (/* reexport safe */ _http_functions__WEBPACK_IMPORTED_MODULE_3__.putWithRetryAsync)
/* harmony export */ });
/* harmony import */ var _ihttp_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ihttp.service */ "./node_modules/@kontent-ai/core-sdk/dist/es6/http/ihttp.service.js");
/* harmony import */ var _http_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./http.service */ "./node_modules/@kontent-ai/core-sdk/dist/es6/http/http.service.js");
/* harmony import */ var _http_models__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./http.models */ "./node_modules/@kontent-ai/core-sdk/dist/es6/http/http.models.js");
/* harmony import */ var _http_functions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./http.functions */ "./node_modules/@kontent-ai/core-sdk/dist/es6/http/http.functions.js");
/* harmony import */ var _http_debugger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./http.debugger */ "./node_modules/@kontent-ai/core-sdk/dist/es6/http/http.debugger.js");
/* harmony import */ var _test_http_service__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./test-http.service */ "./node_modules/@kontent-ai/core-sdk/dist/es6/http/test-http.service.js");






//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@kontent-ai/core-sdk/dist/es6/http/test-http.service.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@kontent-ai/core-sdk/dist/es6/http/test-http.service.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TestHttpService": () => (/* binding */ TestHttpService)
/* harmony export */ });
class TestHttpService {
    constructor(config) {
        this.response = undefined;
        this.error = undefined;
        Object.assign(this, config);
    }
    getAsync(call, options) {
        return this.resolveTestCall();
    }
    postAsync(call, options) {
        return this.resolveTestCall();
    }
    putAsync(call, options) {
        return this.resolveTestCall();
    }
    patchAsync(call, options) {
        return this.resolveTestCall();
    }
    deleteAsync(call, options) {
        return this.resolveTestCall();
    }
    createCancelToken() {
        return {
            cancel: () => { },
            token: undefined
        };
    }
    resolveTestCall() {
        const promise = new Promise((resolve, reject) => {
            if (this.response) {
                resolve(this.response);
            }
            if (this.error) {
                reject(this.error);
            }
            throw Error(`Missing test data`);
        });
        return promise;
    }
}
//# sourceMappingURL=test-http.service.js.map

/***/ }),

/***/ "./node_modules/@kontent-ai/core-sdk/dist/es6/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@kontent-ai/core-sdk/dist/es6/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EnumHelper": () => (/* reexport safe */ _helpers__WEBPACK_IMPORTED_MODULE_0__.EnumHelper),
/* harmony export */   "HeaderHelper": () => (/* reexport safe */ _helpers__WEBPACK_IMPORTED_MODULE_0__.HeaderHelper),
/* harmony export */   "HttpDebugger": () => (/* reexport safe */ _http__WEBPACK_IMPORTED_MODULE_2__.HttpDebugger),
/* harmony export */   "HttpService": () => (/* reexport safe */ _http__WEBPACK_IMPORTED_MODULE_2__.HttpService),
/* harmony export */   "Parameters": () => (/* reexport safe */ _models__WEBPACK_IMPORTED_MODULE_1__.Parameters),
/* harmony export */   "RetryHelper": () => (/* reexport safe */ _helpers__WEBPACK_IMPORTED_MODULE_0__.RetryHelper),
/* harmony export */   "TestHttpService": () => (/* reexport safe */ _http__WEBPACK_IMPORTED_MODULE_2__.TestHttpService),
/* harmony export */   "UrlHelper": () => (/* reexport safe */ _helpers__WEBPACK_IMPORTED_MODULE_0__.UrlHelper),
/* harmony export */   "createCancelToken": () => (/* reexport safe */ _http__WEBPACK_IMPORTED_MODULE_2__.createCancelToken),
/* harmony export */   "deleteWithRetryAsync": () => (/* reexport safe */ _http__WEBPACK_IMPORTED_MODULE_2__.deleteWithRetryAsync),
/* harmony export */   "enumHelper": () => (/* reexport safe */ _helpers__WEBPACK_IMPORTED_MODULE_0__.enumHelper),
/* harmony export */   "extractHeadersFromAxiosResponse": () => (/* reexport safe */ _helpers__WEBPACK_IMPORTED_MODULE_0__.extractHeadersFromAxiosResponse),
/* harmony export */   "getWithRetryAsync": () => (/* reexport safe */ _http__WEBPACK_IMPORTED_MODULE_2__.getWithRetryAsync),
/* harmony export */   "headerHelper": () => (/* reexport safe */ _helpers__WEBPACK_IMPORTED_MODULE_0__.headerHelper),
/* harmony export */   "httpDebugger": () => (/* reexport safe */ _http__WEBPACK_IMPORTED_MODULE_2__.httpDebugger),
/* harmony export */   "patchWithRetryAsync": () => (/* reexport safe */ _http__WEBPACK_IMPORTED_MODULE_2__.patchWithRetryAsync),
/* harmony export */   "postWithRetryAsync": () => (/* reexport safe */ _http__WEBPACK_IMPORTED_MODULE_2__.postWithRetryAsync),
/* harmony export */   "putWithRetryAsync": () => (/* reexport safe */ _http__WEBPACK_IMPORTED_MODULE_2__.putWithRetryAsync),
/* harmony export */   "retryHelper": () => (/* reexport safe */ _helpers__WEBPACK_IMPORTED_MODULE_0__.retryHelper),
/* harmony export */   "urlHelper": () => (/* reexport safe */ _helpers__WEBPACK_IMPORTED_MODULE_0__.urlHelper)
/* harmony export */ });
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ "./node_modules/@kontent-ai/core-sdk/dist/es6/helpers/index.js");
/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./models */ "./node_modules/@kontent-ai/core-sdk/dist/es6/models/index.js");
/* harmony import */ var _http__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./http */ "./node_modules/@kontent-ai/core-sdk/dist/es6/http/index.js");
/* Public API */



//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@kontent-ai/core-sdk/dist/es6/models/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@kontent-ai/core-sdk/dist/es6/models/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Parameters": () => (/* reexport safe */ _parameters__WEBPACK_IMPORTED_MODULE_2__.Parameters)
/* harmony export */ });
/* harmony import */ var _url_models__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./url.models */ "./node_modules/@kontent-ai/core-sdk/dist/es6/models/url.models.js");
/* harmony import */ var _isdk_info__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isdk-info */ "./node_modules/@kontent-ai/core-sdk/dist/es6/models/isdk-info.js");
/* harmony import */ var _parameters__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./parameters */ "./node_modules/@kontent-ai/core-sdk/dist/es6/models/parameters.js");



//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@kontent-ai/core-sdk/dist/es6/models/isdk-info.js":
/*!************************************************************************!*\
  !*** ./node_modules/@kontent-ai/core-sdk/dist/es6/models/isdk-info.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=isdk-info.js.map

/***/ }),

/***/ "./node_modules/@kontent-ai/core-sdk/dist/es6/models/parameters.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@kontent-ai/core-sdk/dist/es6/models/parameters.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Parameters": () => (/* binding */ Parameters)
/* harmony export */ });
var Parameters;
(function (Parameters) {
    class CustomParameter {
        /**
         * Custom parameter
         * @constructor
         * @param {string} name - Name of the parameter
         * @param {string} value - Value of the parameter
         */
        constructor(name, value) {
            this.name = name;
            this.value = value;
            if (!name) {
                throw Error(`Name of the custom parameter is not specified`);
            }
        }
        getParam() {
            return this.name;
        }
        getParamValue() {
            return this.value;
        }
    }
    Parameters.CustomParameter = CustomParameter;
})(Parameters || (Parameters = {}));
//# sourceMappingURL=parameters.js.map

/***/ }),

/***/ "./node_modules/@kontent-ai/core-sdk/dist/es6/models/url.models.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@kontent-ai/core-sdk/dist/es6/models/url.models.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=url.models.js.map

/***/ }),

/***/ "./node_modules/axios/index.js":
/*!*************************************!*\
  !*** ./node_modules/axios/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./lib/axios */ "./node_modules/axios/lib/axios.js");

/***/ }),

/***/ "./node_modules/axios/lib/adapters/xhr.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var settle = __webpack_require__(/*! ./../core/settle */ "./node_modules/axios/lib/core/settle.js");
var cookies = __webpack_require__(/*! ./../helpers/cookies */ "./node_modules/axios/lib/helpers/cookies.js");
var buildURL = __webpack_require__(/*! ./../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
var buildFullPath = __webpack_require__(/*! ../core/buildFullPath */ "./node_modules/axios/lib/core/buildFullPath.js");
var parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ "./node_modules/axios/lib/helpers/parseHeaders.js");
var isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ "./node_modules/axios/lib/helpers/isURLSameOrigin.js");
var transitionalDefaults = __webpack_require__(/*! ../defaults/transitional */ "./node_modules/axios/lib/defaults/transitional.js");
var AxiosError = __webpack_require__(/*! ../core/AxiosError */ "./node_modules/axios/lib/core/AxiosError.js");
var CanceledError = __webpack_require__(/*! ../cancel/CanceledError */ "./node_modules/axios/lib/cancel/CanceledError.js");
var parseProtocol = __webpack_require__(/*! ../helpers/parseProtocol */ "./node_modules/axios/lib/helpers/parseProtocol.js");

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;
    var responseType = config.responseType;
    var onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }

      if (config.signal) {
        config.signal.removeEventListener('abort', onCanceled);
      }
    }

    if (utils.isFormData(requestData) && utils.isStandardBrowserEnv()) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);

    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?
        request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
      var transitional = config.transitional || transitionalDefaults;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config,
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken || config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = function(cancel) {
        if (!request) {
          return;
        }
        reject(!cancel || (cancel && cancel.type) ? new CanceledError() : cancel);
        request.abort();
        request = null;
      };

      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
      }
    }

    if (!requestData) {
      requestData = null;
    }

    var protocol = parseProtocol(fullPath);

    if (protocol && [ 'http', 'https', 'file' ].indexOf(protocol) === -1) {
      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));
      return;
    }


    // Send the request
    request.send(requestData);
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/axios.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");
var Axios = __webpack_require__(/*! ./core/Axios */ "./node_modules/axios/lib/core/Axios.js");
var mergeConfig = __webpack_require__(/*! ./core/mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");
var defaults = __webpack_require__(/*! ./defaults */ "./node_modules/axios/lib/defaults/index.js");

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Expose Cancel & CancelToken
axios.CanceledError = __webpack_require__(/*! ./cancel/CanceledError */ "./node_modules/axios/lib/cancel/CanceledError.js");
axios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ "./node_modules/axios/lib/cancel/CancelToken.js");
axios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");
axios.VERSION = (__webpack_require__(/*! ./env/data */ "./node_modules/axios/lib/env/data.js").version);
axios.toFormData = __webpack_require__(/*! ./helpers/toFormData */ "./node_modules/axios/lib/helpers/toFormData.js");

// Expose AxiosError class
axios.AxiosError = __webpack_require__(/*! ../lib/core/AxiosError */ "./node_modules/axios/lib/core/AxiosError.js");

// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(/*! ./helpers/spread */ "./node_modules/axios/lib/helpers/spread.js");

// Expose isAxiosError
axios.isAxiosError = __webpack_require__(/*! ./helpers/isAxiosError */ "./node_modules/axios/lib/helpers/isAxiosError.js");

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports["default"] = axios;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/CancelToken.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var CanceledError = __webpack_require__(/*! ./CanceledError */ "./node_modules/axios/lib/cancel/CanceledError.js");

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;

  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;

  // eslint-disable-next-line func-names
  this.promise.then(function(cancel) {
    if (!token._listeners) return;

    var i;
    var l = token._listeners.length;

    for (i = 0; i < l; i++) {
      token._listeners[i](cancel);
    }
    token._listeners = null;
  });

  // eslint-disable-next-line func-names
  this.promise.then = function(onfulfilled) {
    var _resolve;
    // eslint-disable-next-line func-names
    var promise = new Promise(function(resolve) {
      token.subscribe(resolve);
      _resolve = resolve;
    }).then(onfulfilled);

    promise.cancel = function reject() {
      token.unsubscribe(_resolve);
    };

    return promise;
  };

  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new CanceledError(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `CanceledError` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Subscribe to the cancel signal
 */

CancelToken.prototype.subscribe = function subscribe(listener) {
  if (this.reason) {
    listener(this.reason);
    return;
  }

  if (this._listeners) {
    this._listeners.push(listener);
  } else {
    this._listeners = [listener];
  }
};

/**
 * Unsubscribe from the cancel signal
 */

CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
  if (!this._listeners) {
    return;
  }
  var index = this._listeners.indexOf(listener);
  if (index !== -1) {
    this._listeners.splice(index, 1);
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/CanceledError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CanceledError.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var AxiosError = __webpack_require__(/*! ../core/AxiosError */ "./node_modules/axios/lib/core/AxiosError.js");
var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function CanceledError(message) {
  // eslint-disable-next-line no-eq-null,eqeqeq
  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED);
  this.name = 'CanceledError';
}

utils.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});

module.exports = CanceledError;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/isCancel.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};


/***/ }),

/***/ "./node_modules/axios/lib/core/Axios.js":
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var buildURL = __webpack_require__(/*! ../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
var InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ "./node_modules/axios/lib/core/InterceptorManager.js");
var dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ "./node_modules/axios/lib/core/dispatchRequest.js");
var mergeConfig = __webpack_require__(/*! ./mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");
var buildFullPath = __webpack_require__(/*! ./buildFullPath */ "./node_modules/axios/lib/core/buildFullPath.js");
var validator = __webpack_require__(/*! ../helpers/validator */ "./node_modules/axios/lib/helpers/validator.js");

var validators = validator.validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(configOrUrl, config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof configOrUrl === 'string') {
    config = config || {};
    config.url = configOrUrl;
  } else {
    config = configOrUrl || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  var transitional = config.transitional;

  if (transitional !== undefined) {
    validator.assertOptions(transitional, {
      silentJSONParsing: validators.transitional(validators.boolean),
      forcedJSONParsing: validators.transitional(validators.boolean),
      clarifyTimeoutError: validators.transitional(validators.boolean)
    }, false);
  }

  // filter out skipped interceptors
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
      return;
    }

    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });

  var promise;

  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest, undefined];

    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);

    promise = Promise.resolve(config);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
  }


  var newConfig = config;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }

  try {
    promise = dispatchRequest(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }

  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  var fullPath = buildFullPath(config.baseURL, config.url);
  return buildURL(fullPath, config.params, config.paramsSerializer);
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/

  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method: method,
        headers: isForm ? {
          'Content-Type': 'multipart/form-data'
        } : {},
        url: url,
        data: data
      }));
    };
  }

  Axios.prototype[method] = generateHTTPMethod();

  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
});

module.exports = Axios;


/***/ }),

/***/ "./node_modules/axios/lib/core/AxiosError.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/core/AxiosError.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  this.message = message;
  this.name = 'AxiosError';
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}

utils.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});

var prototype = AxiosError.prototype;
var descriptors = {};

[
  'ERR_BAD_OPTION_VALUE',
  'ERR_BAD_OPTION',
  'ECONNABORTED',
  'ETIMEDOUT',
  'ERR_NETWORK',
  'ERR_FR_TOO_MANY_REDIRECTS',
  'ERR_DEPRECATED',
  'ERR_BAD_RESPONSE',
  'ERR_BAD_REQUEST',
  'ERR_CANCELED'
// eslint-disable-next-line func-names
].forEach(function(code) {
  descriptors[code] = {value: code};
});

Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, 'isAxiosError', {value: true});

// eslint-disable-next-line func-names
AxiosError.from = function(error, code, config, request, response, customProps) {
  var axiosError = Object.create(prototype);

  utils.toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  });

  AxiosError.call(axiosError, error.message, code, config, request, response);

  axiosError.name = error.name;

  customProps && Object.assign(axiosError, customProps);

  return axiosError;
};

module.exports = AxiosError;


/***/ }),

/***/ "./node_modules/axios/lib/core/InterceptorManager.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;


/***/ }),

/***/ "./node_modules/axios/lib/core/buildFullPath.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/buildFullPath.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isAbsoluteURL = __webpack_require__(/*! ../helpers/isAbsoluteURL */ "./node_modules/axios/lib/helpers/isAbsoluteURL.js");
var combineURLs = __webpack_require__(/*! ../helpers/combineURLs */ "./node_modules/axios/lib/helpers/combineURLs.js");

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/dispatchRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var transformData = __webpack_require__(/*! ./transformData */ "./node_modules/axios/lib/core/transformData.js");
var isCancel = __webpack_require__(/*! ../cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");
var defaults = __webpack_require__(/*! ../defaults */ "./node_modules/axios/lib/defaults/index.js");
var CanceledError = __webpack_require__(/*! ../cancel/CanceledError */ "./node_modules/axios/lib/cancel/CanceledError.js");

/**
 * Throws a `CanceledError` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new CanceledError();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData.call(
    config,
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/core/mergeConfig.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/mergeConfig.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(undefined, config2[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(prop) {
    if (prop in config2) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  var mergeMap = {
    'url': valueFromConfig2,
    'method': valueFromConfig2,
    'data': valueFromConfig2,
    'baseURL': defaultToConfig2,
    'transformRequest': defaultToConfig2,
    'transformResponse': defaultToConfig2,
    'paramsSerializer': defaultToConfig2,
    'timeout': defaultToConfig2,
    'timeoutMessage': defaultToConfig2,
    'withCredentials': defaultToConfig2,
    'adapter': defaultToConfig2,
    'responseType': defaultToConfig2,
    'xsrfCookieName': defaultToConfig2,
    'xsrfHeaderName': defaultToConfig2,
    'onUploadProgress': defaultToConfig2,
    'onDownloadProgress': defaultToConfig2,
    'decompress': defaultToConfig2,
    'maxContentLength': defaultToConfig2,
    'maxBodyLength': defaultToConfig2,
    'beforeRedirect': defaultToConfig2,
    'transport': defaultToConfig2,
    'httpAgent': defaultToConfig2,
    'httpsAgent': defaultToConfig2,
    'cancelToken': defaultToConfig2,
    'socketPath': defaultToConfig2,
    'responseEncoding': defaultToConfig2,
    'validateStatus': mergeDirectKeys
  };

  utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    var merge = mergeMap[prop] || mergeDeepProperties;
    var configValue = merge(prop);
    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
  });

  return config;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/settle.js":
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var AxiosError = __webpack_require__(/*! ./AxiosError */ "./node_modules/axios/lib/core/AxiosError.js");

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError(
      'Request failed with status code ' + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
};


/***/ }),

/***/ "./node_modules/axios/lib/core/transformData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var defaults = __webpack_require__(/*! ../defaults */ "./node_modules/axios/lib/defaults/index.js");

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  var context = this || defaults;
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn.call(context, data, headers);
  });

  return data;
};


/***/ }),

/***/ "./node_modules/axios/lib/defaults/index.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/defaults/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");
var normalizeHeaderName = __webpack_require__(/*! ../helpers/normalizeHeaderName */ "./node_modules/axios/lib/helpers/normalizeHeaderName.js");
var AxiosError = __webpack_require__(/*! ../core/AxiosError */ "./node_modules/axios/lib/core/AxiosError.js");
var transitionalDefaults = __webpack_require__(/*! ./transitional */ "./node_modules/axios/lib/defaults/transitional.js");
var toFormData = __webpack_require__(/*! ../helpers/toFormData */ "./node_modules/axios/lib/helpers/toFormData.js");

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(/*! ../adapters/xhr */ "./node_modules/axios/lib/adapters/xhr.js");
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = __webpack_require__(/*! ../adapters/http */ "./node_modules/axios/lib/adapters/xhr.js");
  }
  return adapter;
}

function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

var defaults = {

  transitional: transitionalDefaults,

  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');

    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }

    var isObjectPayload = utils.isObject(data);
    var contentType = headers && headers['Content-Type'];

    var isFileList;

    if ((isFileList = utils.isFileList(data)) || (isObjectPayload && contentType === 'multipart/form-data')) {
      var _FormData = this.env && this.env.FormData;
      return toFormData(isFileList ? {'files[]': data} : data, _FormData && new _FormData());
    } else if (isObjectPayload || contentType === 'application/json') {
      setContentTypeIfUnset(headers, 'application/json');
      return stringifySafely(data);
    }

    return data;
  }],

  transformResponse: [function transformResponse(data) {
    var transitional = this.transitional || defaults.transitional;
    var silentJSONParsing = transitional && transitional.silentJSONParsing;
    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

    if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  env: {
    FormData: __webpack_require__(/*! ./env/FormData */ "./node_modules/axios/lib/helpers/null.js")
  },

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },

  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*'
    }
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;


/***/ }),

/***/ "./node_modules/axios/lib/defaults/transitional.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/defaults/transitional.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";


module.exports = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};


/***/ }),

/***/ "./node_modules/axios/lib/env/data.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/env/data.js ***!
  \********************************************/
/***/ ((module) => {

module.exports = {
  "version": "0.27.2"
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/bind.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/buildURL.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/combineURLs.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/cookies.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAxiosError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAxiosError.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
module.exports = function isAxiosError(payload) {
  return utils.isObject(payload) && (payload.isAxiosError === true);
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
      function resolveURL(url) {
        var href = url;

        if (msie) {
        // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/normalizeHeaderName.js":
/*!***************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/null.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/null.js ***!
  \************************************************/
/***/ ((module) => {

// eslint-disable-next-line strict
module.exports = null;


/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseProtocol.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseProtocol.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";


module.exports = function parseProtocol(url) {
  var match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || '';
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/spread.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/toFormData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/toFormData.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Convert a data object to FormData
 * @param {Object} obj
 * @param {?Object} [formData]
 * @returns {Object}
 **/

function toFormData(obj, formData) {
  // eslint-disable-next-line no-param-reassign
  formData = formData || new FormData();

  var stack = [];

  function convertValue(value) {
    if (value === null) return '';

    if (utils.isDate(value)) {
      return value.toISOString();
    }

    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
      return typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
    }

    return value;
  }

  function build(data, parentKey) {
    if (utils.isPlainObject(data) || utils.isArray(data)) {
      if (stack.indexOf(data) !== -1) {
        throw Error('Circular reference detected in ' + parentKey);
      }

      stack.push(data);

      utils.forEach(data, function each(value, key) {
        if (utils.isUndefined(value)) return;
        var fullKey = parentKey ? parentKey + '.' + key : key;
        var arr;

        if (value && !parentKey && typeof value === 'object') {
          if (utils.endsWith(key, '{}')) {
            // eslint-disable-next-line no-param-reassign
            value = JSON.stringify(value);
          } else if (utils.endsWith(key, '[]') && (arr = utils.toArray(value))) {
            // eslint-disable-next-line func-names
            arr.forEach(function(el) {
              !utils.isUndefined(el) && formData.append(fullKey, convertValue(el));
            });
            return;
          }
        }

        build(value, fullKey);
      });

      stack.pop();
    } else {
      formData.append(parentKey, convertValue(data));
    }
  }

  build(obj);

  return formData;
}

module.exports = toFormData;


/***/ }),

/***/ "./node_modules/axios/lib/helpers/validator.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/validator.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var VERSION = (__webpack_require__(/*! ../env/data */ "./node_modules/axios/lib/env/data.js").version);
var AxiosError = __webpack_require__(/*! ../core/AxiosError */ "./node_modules/axios/lib/core/AxiosError.js");

var validators = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {
  validators[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

var deprecatedWarnings = {};

/**
 * Transitional option validator
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 * @returns {function}
 */
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return function(value, opt, opts) {
    if (validator === false) {
      throw new AxiosError(
        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
        AxiosError.ERR_DEPRECATED
      );
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);
  }
  var keys = Object.keys(options);
  var i = keys.length;
  while (i-- > 0) {
    var opt = keys[i];
    var validator = schema[opt];
    if (validator) {
      var value = options[opt];
      var result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}

module.exports = {
  assertOptions: assertOptions,
  validators: validators
};


/***/ }),

/***/ "./node_modules/axios/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

// eslint-disable-next-line func-names
var kindOf = (function(cache) {
  // eslint-disable-next-line func-names
  return function(thing) {
    var str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
  };
})(Object.create(null));

function kindOfTest(type) {
  type = type.toLowerCase();
  return function isKindOf(thing) {
    return kindOf(thing) === type;
  };
}

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return Array.isArray(val);
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
var isArrayBuffer = kindOfTest('ArrayBuffer');


/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
function isPlainObject(val) {
  if (kindOf(val) !== 'object') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}

/**
 * Determine if a value is a Date
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
var isDate = kindOfTest('Date');

/**
 * Determine if a value is a File
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
var isFile = kindOfTest('File');

/**
 * Determine if a value is a Blob
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
var isBlob = kindOfTest('Blob');

/**
 * Determine if a value is a FileList
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
var isFileList = kindOfTest('FileList');

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} thing The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(thing) {
  var pattern = '[object FormData]';
  return thing && (
    (typeof FormData === 'function' && thing instanceof FormData) ||
    toString.call(thing) === pattern ||
    (isFunction(thing.toString) && thing.toString() === pattern)
  );
}

/**
 * Determine if a value is a URLSearchParams object
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
var isURLSearchParams = kindOfTest('URLSearchParams');

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 */

function inherits(constructor, superConstructor, props, descriptors) {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  props && Object.assign(constructor.prototype, props);
}

/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function} [filter]
 * @returns {Object}
 */

function toFlatObject(sourceObj, destObj, filter) {
  var props;
  var i;
  var prop;
  var merged = {};

  destObj = destObj || {};

  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if (!merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = Object.getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

  return destObj;
}

/*
 * determines whether a string ends with the characters of a specified string
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 * @returns {boolean}
 */
function endsWith(str, searchString, position) {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  var lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
}


/**
 * Returns new array from array like object
 * @param {*} [thing]
 * @returns {Array}
 */
function toArray(thing) {
  if (!thing) return null;
  var i = thing.length;
  if (isUndefined(i)) return null;
  var arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
}

// eslint-disable-next-line func-names
var isTypedArray = (function(TypedArray) {
  // eslint-disable-next-line func-names
  return function(thing) {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== 'undefined' && Object.getPrototypeOf(Uint8Array));

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM,
  inherits: inherits,
  toFlatObject: toFlatObject,
  kindOf: kindOf,
  kindOfTest: kindOfTest,
  endsWith: endsWith,
  toArray: toArray,
  isTypedArray: isTypedArray,
  isFileList: isFileList
};


/***/ }),

/***/ "./node_modules/querystringify/index.js":
/*!**********************************************!*\
  !*** ./node_modules/querystringify/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


var has = Object.prototype.hasOwnProperty
  , undef;

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String|Null} The decoded string.
 * @api private
 */
function decode(input) {
  try {
    return decodeURIComponent(input.replace(/\+/g, ' '));
  } catch (e) {
    return null;
  }
}

/**
 * Attempts to encode a given input.
 *
 * @param {String} input The string that needs to be encoded.
 * @returns {String|Null} The encoded string.
 * @api private
 */
function encode(input) {
  try {
    return encodeURIComponent(input);
  } catch (e) {
    return null;
  }
}

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?#&]+)=?([^&]*)/g
    , result = {}
    , part;

  while (part = parser.exec(query)) {
    var key = decode(part[1])
      , value = decode(part[2]);

    //
    // Prevent overriding of existing properties. This ensures that build-in
    // methods like `toString` or __proto__ are not overriden by malicious
    // querystrings.
    //
    // In the case if failed decoding, we want to omit the key/value pairs
    // from the result.
    //
    if (key === null || value === null || key in result) continue;
    result[key] = value;
  }

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = []
    , value
    , key;

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (key in obj) {
    if (has.call(obj, key)) {
      value = obj[key];

      //
      // Edge cases where we actually want to encode the value to an empty
      // string instead of the stringified value.
      //
      if (!value && (value === null || value === undef || isNaN(value))) {
        value = '';
      }

      key = encode(key);
      value = encode(value);

      //
      // If we failed to encode the strings, we should bail out as we don't
      // want to add invalid strings to the query.
      //
      if (key === null || value === null) continue;
      pairs.push(key +'='+ value);
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;


/***/ }),

/***/ "./node_modules/requires-port/index.js":
/*!*********************************************!*\
  !*** ./node_modules/requires-port/index.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";


/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};


/***/ }),

/***/ "./lib/client/delivery-client.factory.ts":
/*!***********************************************!*\
  !*** ./lib/client/delivery-client.factory.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createDeliveryClient = void 0;
const delivery_client_1 = __webpack_require__(/*! ./delivery-client */ "./lib/client/delivery-client.ts");
function createDeliveryClient(config) {
    return new delivery_client_1.DeliveryClient(config);
}
exports.createDeliveryClient = createDeliveryClient;


/***/ }),

/***/ "./lib/client/delivery-client.ts":
/*!***************************************!*\
  !*** ./lib/client/delivery-client.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeliveryClient = void 0;
const core_sdk_1 = __webpack_require__(/*! @kontent-ai/core-sdk */ "./node_modules/@kontent-ai/core-sdk/dist/es6/index.js");
const query_1 = __webpack_require__(/*! ../query */ "./lib/query/index.ts");
const sdk_info_generated_1 = __webpack_require__(/*! ../sdk-info.generated */ "./lib/sdk-info.generated.ts");
const services_1 = __webpack_require__(/*! ../services */ "./lib/services/index.ts");
class DeliveryClient {
    /**
     * Delivery client used to fetch data from Kontent.ai
     * @constructor
     * @param {IDeliveryClientConfig} config - The client configuration
     */
    constructor(config) {
        this.config = config;
        if (!config) {
            throw Error(`Delivery client configuration is not set`);
        }
        this.mappingService = new services_1.MappingService(config);
        this.queryService = new services_1.QueryService(config, config.httpService ? config.httpService : new core_sdk_1.HttpService(), {
            host: sdk_info_generated_1.sdkInfo.host,
            name: sdk_info_generated_1.sdkInfo.name,
            version: sdk_info_generated_1.sdkInfo.version
        }, this.mappingService);
    }
    /**
     * Gets query for multiple languages
     */
    languages() {
        return new query_1.LanguagesQuery(this.config, this.queryService);
    }
    /**
     * Gets query for multiple types
     */
    types() {
        return new query_1.MultipleTypeQuery(this.config, this.queryService);
    }
    /**
     * Gets query for single type
     * @param {string} typeCodename - Codename of the type to fetch
     */
    type(typeCodename) {
        return new query_1.SingleTypeQuery(this.config, this.queryService, typeCodename);
    }
    /**
     * Gets query for multiple items
     */
    items() {
        return new query_1.MultipleItemsQuery(this.config, this.queryService);
    }
    /**
     * Gets query for single item
     * @param {string} codename - Codename of item to fetch
     */
    item(codename) {
        return new query_1.SingleItemQuery(this.config, this.queryService, codename);
    }
    /**
     * Gets query for items feed. Executes single HTTP request only. Might not get all items from your Kontent.ai project.
     */
    itemsFeed() {
        return new query_1.ItemsFeedQuery(this.config, this.queryService);
    }
    /**
     * Gets query for single taxonomy
     * @param {string} codename - Codename of taxonomy to fetch
     */
    taxonomy(codename) {
        return new query_1.TaxonomyQuery(this.config, this.queryService, codename);
    }
    /**
     * Gets query for multiple taxonomies
     */
    taxonomies() {
        return new query_1.TaxonomiesQuery(this.config, this.queryService);
    }
    /**
     * Gets query for an element within a type
     * @param {string} typeCodename - Codename of the type
     * @param {string} elementCodename - Codename of the element
     */
    element(typeCodename, elementCodename) {
        return new query_1.ElementQuery(this.config, this.queryService, typeCodename, elementCodename);
    }
    /**
     * Gets query for initializing sync
     */
    initializeSync() {
        return new query_1.InitializeSyncQuery(this.config, this.queryService);
    }
    /**
     * Gets query fetching delta updates of content items
     */
    syncChanges() {
        return new query_1.SyncChangesQuery(this.config, this.queryService);
    }
}
exports.DeliveryClient = DeliveryClient;


/***/ }),

/***/ "./lib/client/idelivery-client.interface.ts":
/*!**************************************************!*\
  !*** ./lib/client/idelivery-client.interface.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./lib/client/index.ts":
/*!*****************************!*\
  !*** ./lib/client/index.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./delivery-client */ "./lib/client/delivery-client.ts"), exports);
__exportStar(__webpack_require__(/*! ./idelivery-client.interface */ "./lib/client/idelivery-client.interface.ts"), exports);
__exportStar(__webpack_require__(/*! ./delivery-client.factory */ "./lib/client/delivery-client.factory.ts"), exports);


/***/ }),

/***/ "./lib/config/delivery-configs.ts":
/*!****************************************!*\
  !*** ./lib/config/delivery-configs.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./lib/config/index.ts":
/*!*****************************!*\
  !*** ./lib/config/index.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./delivery-configs */ "./lib/config/delivery-configs.ts"), exports);


/***/ }),

/***/ "./lib/contracts/contracts.ts":
/*!************************************!*\
  !*** ./lib/contracts/contracts.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./lib/contracts/index.ts":
/*!********************************!*\
  !*** ./lib/contracts/index.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./contracts */ "./lib/contracts/contracts.ts"), exports);


/***/ }),

/***/ "./lib/elements/element-models.ts":
/*!****************************************!*\
  !*** ./lib/elements/element-models.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./lib/elements/element-resolver.ts":
/*!******************************************!*\
  !*** ./lib/elements/element-resolver.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./lib/elements/element-type.ts":
/*!**************************************!*\
  !*** ./lib/elements/element-type.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ElementType = void 0;
/**
* Represents codename of Kontent.ai element types
*/
var ElementType;
(function (ElementType) {
    ElementType["Text"] = "text";
    ElementType["Number"] = "number";
    ElementType["ModularContent"] = "modular_content";
    ElementType["Asset"] = "asset";
    ElementType["DateTime"] = "date_time";
    ElementType["RichText"] = "rich_text";
    ElementType["MultipleChoice"] = "multiple_choice";
    ElementType["UrlSlug"] = "url_slug";
    ElementType["Taxonomy"] = "taxonomy";
    ElementType["Custom"] = "custom";
    ElementType["Unknown"] = "unknown";
})(ElementType = exports.ElementType || (exports.ElementType = {}));


/***/ }),

/***/ "./lib/elements/elements.ts":
/*!**********************************!*\
  !*** ./lib/elements/elements.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./lib/elements/index.ts":
/*!*******************************!*\
  !*** ./lib/elements/index.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./element-models */ "./lib/elements/element-models.ts"), exports);
__exportStar(__webpack_require__(/*! ./element-type */ "./lib/elements/element-type.ts"), exports);
__exportStar(__webpack_require__(/*! ./elements */ "./lib/elements/elements.ts"), exports);
__exportStar(__webpack_require__(/*! ./element-resolver */ "./lib/elements/element-resolver.ts"), exports);


/***/ }),

/***/ "./lib/images/image-url-transformation-builder.factory.ts":
/*!****************************************************************!*\
  !*** ./lib/images/image-url-transformation-builder.factory.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.transformImageUrl = void 0;
const image_url_transformation_builder_1 = __webpack_require__(/*! ./image-url-transformation-builder */ "./lib/images/image-url-transformation-builder.ts");
function transformImageUrl(url) {
    return new image_url_transformation_builder_1.ImageUrlTransformationBuilder(url);
}
exports.transformImageUrl = transformImageUrl;


/***/ }),

/***/ "./lib/images/image-url-transformation-builder.ts":
/*!********************************************************!*\
  !*** ./lib/images/image-url-transformation-builder.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ImageUrlTransformationBuilder = void 0;
const models_1 = __webpack_require__(/*! ../models */ "./lib/models/index.ts");
class ImageUrlTransformationBuilder {
    constructor(
    /** Image url */
    imageUrl) {
        this.imageUrl = imageUrl;
        this.queryParams = [];
        this.automaticFormatValue = 'format';
    }
    /**
     * Used to add custom parameters to existing query string
     * @param param Parameter (may or may not include value)
     */
    withCustomParam(param) {
        this.queryParams.push(new models_1.Parameters.CustomParameter(param));
        return this;
    }
    /**
     * The dpr transformation is used to serve correctly sized images for devices that expose a device pixel ratio.
     * @param dpr A required DPR value.
     */
    withDpr(dpr) {
        this.queryParams.push(new models_1.Parameters.QueryParameter('dpr', dpr.toString()));
        return this;
    }
    /**
     * Applies the crop transformation that removes pixels from an image outside the specified rectangle.
     * @param x Rectangle offset on the X-axis.
     * @param y Rectangle offset on the Y-axis.
     * @param width Rectangle width.
     * @param height Rectangle height.
     */
    withRectangleCrop(x, y, width, height) {
        this.queryParams.push(new models_1.Parameters.QueryParameter('rect', [x, y, width, height].join(',')));
        return this;
    }
    /**
     * Applies the crop transformation centered on the specified point.
     * @param x Focal point X coordinate.
     * @param y Focal point Y coordinate.
     * @param z Zoom of the transformation.
     */
    withFocalPointCrop(x, y, z) {
        this.withFitMode('crop');
        this.queryParams.push(new models_1.Parameters.QueryParameter('crop', 'focalpoint'));
        this.queryParams.push(new models_1.Parameters.QueryParameter('fp-x', x.toString()));
        this.queryParams.push(new models_1.Parameters.QueryParameter('fp-y', y.toString()));
        this.queryParams.push(new models_1.Parameters.QueryParameter('fp-z', z.toString()));
        return this;
    }
    /**
     * Enables WebP image support.
     * @param compression Specifies the lossy or lossless compression.
     */
    withAutomaticFormat(backupFormat) {
        this.queryParams.push(new models_1.Parameters.QueryParameter('auto', this.automaticFormatValue));
        if (backupFormat) {
            this.withFormat(backupFormat);
        }
        return this;
    }
    /**
     * The fit transformation controls how the output image is fit to its target dimensions after resizing.
     * @param fitMode Specifies the mode for the transformation.
     */
    withFitMode(fitMode) {
        this.queryParams.push(new models_1.Parameters.QueryParameter('fit', fitMode));
        return this;
    }
    /**
     * Specifies the compression mode for the WebP image transformations.
     * @param compression Specifies the lossy or lossless compression.
     */
    withCompression(compression) {
        this.queryParams.push(new models_1.Parameters.QueryParameter('lossless', compression === 'lossless' ? 'true' : 'false'));
        return this;
    }
    /**
     * Applies the quality parameter that enables control over the compression level for lossy file-formatted images.
     * @param quality The required quality of the image.
     */
    withQuality(quality) {
        this.queryParams.push(new models_1.Parameters.QueryParameter('q', quality.toString()));
        return this;
    }
    /**
     * The format transformation enables the source image to be converted (a.k.a., "transcoded") from
     * one encoded format to another. This is very useful when the source image has been saved in a sub-optimal
     * file format that hinders performance.
     * @param format Target image file type.
     */
    withFormat(format) {
        this.queryParams.push(new models_1.Parameters.QueryParameter('fm', format));
        return this;
    }
    /**
     * The height transformation enables dynamic height resizing based on pixels and percent values.
     * @param height A required image height.
     */
    withHeight(height) {
        this.queryParams.push(new models_1.Parameters.QueryParameter('h', height.toString()));
        return this;
    }
    /**
     * The width transformation enables dynamic width resizing based on pixels and percent values.
     * @param width A required image width.
     */
    withWidth(width) {
        this.queryParams.push(new models_1.Parameters.QueryParameter('w', width.toString()));
        return this;
    }
    /**
     * Gets params applied to image
     */
    getParams() {
        return this.queryParams;
    }
    /**
     * Gets query string part of the image URL
     */
    getQueryString() {
        let query = '';
        this.queryParams.forEach(filter => {
            if (query.indexOf('?') > -1) {
                query = query + '&' + filter.getParam();
            }
            else {
                query = query + '?' + filter.getParam();
            }
        });
        return query;
    }
    /**
     * Gets full transformed url to image with parameters
     */
    getUrl() {
        return this.imageUrl + this.getQueryString();
    }
}
exports.ImageUrlTransformationBuilder = ImageUrlTransformationBuilder;


/***/ }),

/***/ "./lib/images/image.models.ts":
/*!************************************!*\
  !*** ./lib/images/image.models.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./lib/images/index.ts":
/*!*****************************!*\
  !*** ./lib/images/index.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./image-url-transformation-builder */ "./lib/images/image-url-transformation-builder.ts"), exports);
__exportStar(__webpack_require__(/*! ./image.models */ "./lib/images/image.models.ts"), exports);
__exportStar(__webpack_require__(/*! ./image-url-transformation-builder.factory */ "./lib/images/image-url-transformation-builder.factory.ts"), exports);


/***/ }),

/***/ "./lib/index.ts":
/*!**********************!*\
  !*** ./lib/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// Public API
__exportStar(__webpack_require__(/*! ./client */ "./lib/client/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./sdk-info.generated */ "./lib/sdk-info.generated.ts"), exports);
__exportStar(__webpack_require__(/*! ./config */ "./lib/config/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./contracts */ "./lib/contracts/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./elements */ "./lib/elements/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./parser */ "./lib/parser/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./resolvers */ "./lib/resolvers/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./services */ "./lib/services/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./mappers */ "./lib/mappers/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./query */ "./lib/query/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./models */ "./lib/models/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./images */ "./lib/images/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./utilities */ "./lib/utilities/index.ts"), exports);


/***/ }),

/***/ "./lib/mappers/element.mapper.ts":
/*!***************************************!*\
  !*** ./lib/mappers/element.mapper.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ElementMapper = void 0;
const core_sdk_1 = __webpack_require__(/*! @kontent-ai/core-sdk */ "./node_modules/@kontent-ai/core-sdk/dist/es6/index.js");
const utilities_1 = __webpack_require__(/*! ../utilities */ "./lib/utilities/index.ts");
const elements_1 = __webpack_require__(/*! ../elements */ "./lib/elements/index.ts");
class ElementMapper {
    constructor(config) {
        this.config = config;
    }
    mapElements(data) {
        // return processed item to avoid infinite recursion
        const processedItem = data.processedItems[data.dataToMap.item.system.codename];
        if (processedItem) {
            // item was already resolved
            return {
                item: processedItem,
                processedItems: data.processedItems,
                preparedItems: data.preparedItems,
                processingStartedForCodenames: data.processingStartedForCodenames
            };
        }
        const preparedItem = data.preparedItems[data.dataToMap.item.system.codename];
        const itemInstance = preparedItem === null || preparedItem === void 0 ? void 0 : preparedItem.item;
        if (!itemInstance) {
            // item is not present in response
            return undefined;
        }
        // mapp elements
        const elementCodenames = Object.getOwnPropertyNames(data.dataToMap.rawItem.elements);
        for (const elementCodename of elementCodenames) {
            const elementMap = this.resolveElementMap(itemInstance, elementCodename);
            const elementWrapper = {
                system: data.dataToMap.item.system,
                rawElement: data.dataToMap.rawItem.elements[elementCodename],
                element: elementMap.resolvedName
            };
            if (elementMap.shouldMapElement) {
                const mappedElement = this.mapElement({
                    elementWrapper: elementWrapper,
                    item: itemInstance,
                    preparedItems: data.preparedItems,
                    processingStartedForCodenames: data.processingStartedForCodenames,
                    processedItems: data.processedItems
                });
                // set mapped elements
                itemInstance.elements[elementMap.resolvedName] = mappedElement;
            }
        }
        return {
            item: itemInstance,
            processedItems: data.processedItems,
            preparedItems: data.preparedItems,
            processingStartedForCodenames: data.processingStartedForCodenames
        };
    }
    mapElement(data) {
        const elementType = core_sdk_1.enumHelper.getEnumFromValue(elements_1.ElementType, data.elementWrapper.rawElement.type);
        if (elementType) {
            if (elementType === elements_1.ElementType.ModularContent) {
                return this.mapLinkedItemsElement({
                    elementWrapper: data.elementWrapper,
                    preparedItems: data.preparedItems,
                    processingStartedForCodenames: data.processingStartedForCodenames,
                    processedItems: data.processedItems
                });
            }
            if (elementType === elements_1.ElementType.Text) {
                return this.mapTextElement(data.elementWrapper);
            }
            if (elementType === elements_1.ElementType.Asset) {
                return this.mapAssetsElement(data.elementWrapper);
            }
            if (elementType === elements_1.ElementType.Number) {
                return this.mapNumberElement(data.elementWrapper);
            }
            if (elementType === elements_1.ElementType.MultipleChoice) {
                return this.mapMultipleChoiceElement(data.elementWrapper);
            }
            if (elementType === elements_1.ElementType.DateTime) {
                return this.mapDateTimeElement(data.elementWrapper);
            }
            if (elementType === elements_1.ElementType.RichText) {
                // add to parent items
                return this.mapRichTextElement(data.elementWrapper, data.processedItems, data.processingStartedForCodenames, data.preparedItems);
            }
            if (elementType === elements_1.ElementType.UrlSlug) {
                return this.mapUrlSlugElement(data.elementWrapper);
            }
            if (elementType === elements_1.ElementType.Taxonomy) {
                return this.mapTaxonomyElement(data.elementWrapper);
            }
            if (elementType === elements_1.ElementType.Custom) {
                return this.mapCustomElement(data.elementWrapper);
            }
        }
        console.warn(`Could not map element '${data.elementWrapper.rawElement.name}' of type '${data.elementWrapper.rawElement.type}'. Returning unknown element instead.`);
        return this.mapUnknowElement(data.elementWrapper);
    }
    mapRichTextElement(elementWrapper, processedItems, processingStartedForCodenames, preparedItems) {
        const rawElement = elementWrapper.rawElement;
        // get all linked items and linked items codenames nested in rich text
        const richTextLinkedItems = [];
        const richTextLinkedItemsCodenames = [];
        // The Kontent Delivery API is not guaranteed to return rich-text modular_content array items in the same order in which they appear inside the `value` property.
        // We extract the modular_content codenames in the rich-text value and sort the raw modular_content based on that order instead.
        const rawModularContentCodenamesMatches = rawElement.value.matchAll(/<object[^>]+data-codename=\"(?<codename>[a-z0-9_]*)\".*?>/g);
        const rawModularContentCodenamesSorted = Array.from(rawModularContentCodenamesMatches).reduce((acc, match) => {
            if (match.groups && match.groups.codename) {
                acc.push(match.groups.codename);
            }
            return acc;
        }, []);
        const rawModularContentCodenames = [...rawElement.modular_content].sort(function (a, b) {
            return rawModularContentCodenamesSorted.indexOf(a) - rawModularContentCodenamesSorted.indexOf(b);
        });
        for (const codename of rawModularContentCodenames) {
            richTextLinkedItemsCodenames.push(codename);
            // get linked item and check if it exists (it might not be included in response due to 'Depth' parameter)
            const preparedData = preparedItems[codename];
            // first try to get existing item
            if (this.canMapLinkedItems()) {
                const existingLinkedItem = this.getOrSaveLinkedItemForElement(codename, rawElement, processedItems, processingStartedForCodenames, preparedItems);
                if (existingLinkedItem) {
                    // item was found, add it to linked items
                    richTextLinkedItems.push(existingLinkedItem);
                }
                else {
                    // item was not found or not yet resolved
                    if (preparedData) {
                        const mappedLinkedItemResult = this.mapElements({
                            dataToMap: preparedData,
                            preparedItems: preparedItems,
                            processingStartedForCodenames: processingStartedForCodenames,
                            processedItems: processedItems
                        });
                        // add mapped linked item to result
                        if (mappedLinkedItemResult) {
                            richTextLinkedItems.push(mappedLinkedItemResult.item);
                        }
                    }
                }
            }
        }
        // get rich text images
        const richTextImagesResult = this.getRichTextImages(rawElement.images);
        // extract and map links & images
        const links = this.mapRichTextLinks(rawElement.links);
        const images = richTextImagesResult.richTextImages;
        // replace asset urls in html
        const richTextHtml = this.getRichTextHtml(rawElement.value, richTextImagesResult.imageUrlRecords);
        return {
            images: images,
            linkedItemCodenames: richTextLinkedItemsCodenames,
            linkedItems: richTextLinkedItems,
            links: links,
            name: rawElement.name,
            type: elements_1.ElementType.RichText,
            value: richTextHtml
        };
    }
    mapDateTimeElement(elementWrapper) {
        var _a;
        const rawElement = elementWrapper.rawElement;
        return Object.assign(Object.assign({}, this.buildElement(elementWrapper, elements_1.ElementType.DateTime, () => rawElement.value)), { displayTimeZone: (_a = rawElement.display_timezone) !== null && _a !== void 0 ? _a : null });
    }
    mapMultipleChoiceElement(elementWrapper) {
        return this.buildElement(elementWrapper, elements_1.ElementType.MultipleChoice, () => elementWrapper.rawElement.value);
    }
    mapNumberElement(elementWrapper) {
        return this.buildElement(elementWrapper, elements_1.ElementType.Number, () => {
            if (elementWrapper.rawElement.value === 0) {
                return 0;
            }
            else if (elementWrapper.rawElement.value) {
                return +elementWrapper.rawElement.value;
            }
            return null;
        });
    }
    mapTextElement(elementWrapper) {
        return this.buildElement(elementWrapper, elements_1.ElementType.Text, () => elementWrapper.rawElement.value);
    }
    mapAssetsElement(elementWrapper) {
        return this.buildElement(elementWrapper, elements_1.ElementType.Asset, () => {
            var _a;
            const assetContracts = elementWrapper.rawElement.value;
            const assets = [];
            for (const assetContract of assetContracts) {
                let renditions = null;
                // get asset url (custom domain may be configured)
                const assetUrl = this.config.assetsDomain
                    ? utilities_1.deliveryUrlHelper.replaceAssetDomain(assetContract.url, this.config.assetsDomain)
                    : assetContract.url;
                if (assetContract.renditions) {
                    renditions = {};
                    for (const renditionPresetKey of Object.keys(assetContract.renditions)) {
                        const rendition = assetContract.renditions[renditionPresetKey];
                        renditions[renditionPresetKey] = Object.assign(Object.assign({}, rendition), { url: `${assetUrl}?${rendition.query}` // enhance rendition with absolute url
                         });
                    }
                }
                const renditionToBeApplied = (this.config.defaultRenditionPreset && (renditions === null || renditions === void 0 ? void 0 : renditions[this.config.defaultRenditionPreset])) || null;
                const finalUrl = (_a = renditionToBeApplied === null || renditionToBeApplied === void 0 ? void 0 : renditionToBeApplied.url) !== null && _a !== void 0 ? _a : assetUrl;
                const asset = Object.assign(Object.assign({}, assetContract), { url: finalUrl, // use custom url of asset which may contain custom domain and applied rendition
                    renditions });
                assets.push(asset);
            }
            return assets;
        });
    }
    mapTaxonomyElement(elementWrapper) {
        var _a;
        return Object.assign(Object.assign({}, this.buildElement(elementWrapper, elements_1.ElementType.Taxonomy, () => elementWrapper.rawElement.value)), { taxonomyGroup: (_a = elementWrapper.rawElement.taxonomy_group) !== null && _a !== void 0 ? _a : null });
    }
    mapUnknowElement(elementWrapper) {
        return this.buildElement(elementWrapper, elements_1.ElementType.Unknown, () => elementWrapper.rawElement.value);
    }
    mapCustomElement(elementWrapper) {
        // try to find element resolver
        if (this.config.elementResolver) {
            const elementResolverValue = this.config.elementResolver(elementWrapper);
            if (elementResolverValue) {
                return this.buildElement(elementWrapper, elements_1.ElementType.Custom, () => elementResolverValue);
            }
        }
        return this.buildElement(elementWrapper, elements_1.ElementType.Custom, () => elementWrapper.rawElement.value);
    }
    mapUrlSlugElement(elementWrapper) {
        return this.buildElement(elementWrapper, elements_1.ElementType.UrlSlug, () => elementWrapper.rawElement.value);
    }
    mapLinkedItemsElement(data) {
        // prepare linked items
        const linkedItems = [];
        // value = array of item codenames
        const linkedItemCodenames = data.elementWrapper.rawElement.value;
        for (const codename of linkedItemCodenames) {
            if (this.canMapLinkedItems()) {
                const linkedItem = this.getOrSaveLinkedItemForElement(codename, data.elementWrapper.rawElement, data.processedItems, data.processingStartedForCodenames, data.preparedItems);
                if (linkedItem) {
                    // add item to result
                    linkedItems.push(linkedItem);
                }
            }
        }
        return Object.assign(Object.assign({}, this.buildElement(data.elementWrapper, elements_1.ElementType.ModularContent, () => linkedItemCodenames)), { linkedItems: linkedItems });
    }
    getOrSaveLinkedItemForElement(codename, element, processedItems, mappingStartedForCodenames, preparedItems) {
        // first check if item was already resolved and return it if it was
        const processedItem = processedItems[codename];
        if (processedItem) {
            // item was already resolved
            return processedItem;
        }
        const preparedItem = preparedItems[codename];
        if (mappingStartedForCodenames.includes(codename)) {
            return preparedItem === null || preparedItem === void 0 ? void 0 : preparedItem.item;
        }
        mappingStartedForCodenames.push(codename);
        // throw error if item is not in response and errors are not skipped
        if (!preparedItem) {
            return undefined;
        }
        let mappedLinkedItem;
        // original resolving if item is still undefined
        const mappedLinkedItemResult = this.mapElements({
            dataToMap: preparedItem,
            preparedItems: preparedItems,
            processingStartedForCodenames: mappingStartedForCodenames,
            processedItems: processedItems
        });
        if (mappedLinkedItemResult) {
            mappedLinkedItem = mappedLinkedItemResult.item;
            // add to processed items
            processedItems[codename] = mappedLinkedItem;
        }
        return mappedLinkedItem;
    }
    mapRichTextLinks(linksJson) {
        const links = [];
        for (const linkId of Object.keys(linksJson)) {
            const linkRaw = linksJson[linkId];
            links.push({
                codename: linkRaw.codename,
                linkId: linkId,
                urlSlug: linkRaw.url_slug,
                type: linkRaw.type
            });
        }
        return links;
    }
    getRichTextHtml(richTextHtml, richTextImageRecords) {
        for (const richTextImageRecord of richTextImageRecords) {
            // replace rich text image url if it differs
            if (richTextImageRecord.newUrl !== richTextImageRecord.originalUrl) {
                richTextHtml = richTextHtml.replace(new RegExp(richTextImageRecord.originalUrl, 'g'), richTextImageRecord.newUrl);
            }
        }
        return richTextHtml;
    }
    getRichTextImages(imagesJson) {
        var _a, _b, _c;
        const images = [];
        const imageUrlRecords = [];
        for (const imageId of Object.keys(imagesJson)) {
            const imageRaw = imagesJson[imageId];
            // image may contain custom asset domain
            const imageUrl = this.config.assetsDomain
                ? utilities_1.deliveryUrlHelper.replaceAssetDomain(imageRaw.url, this.config.assetsDomain)
                : imageRaw.url;
            images.push({
                description: (_a = imageRaw.description) !== null && _a !== void 0 ? _a : null,
                imageId: imageRaw.image_id,
                url: imageUrl,
                height: (_b = imageRaw.height) !== null && _b !== void 0 ? _b : null,
                width: (_c = imageRaw.width) !== null && _c !== void 0 ? _c : null
            });
            imageUrlRecords.push({
                originalUrl: imageRaw.url,
                newUrl: imageUrl
            });
        }
        return {
            imageUrlRecords: imageUrlRecords,
            richTextImages: images
        };
    }
    resolveElementMap(item, originalElementCodename) {
        let resolvedElementPropertyName = undefined;
        if (this.config.propertyNameResolver) {
            resolvedElementPropertyName = this.config.propertyNameResolver(item.system.type, originalElementCodename);
        }
        if (!resolvedElementPropertyName) {
            // use original element codename
            resolvedElementPropertyName = originalElementCodename;
        }
        return {
            resolvedName: resolvedElementPropertyName,
            shouldMapElement: true
        };
    }
    buildElement(elementWrapper, type, valueFactory) {
        return {
            name: elementWrapper.rawElement.name,
            type: type,
            value: valueFactory()
        };
    }
    canMapLinkedItems() {
        if (!this.config.linkedItemsReferenceHandler) {
            return true;
        }
        return this.config.linkedItemsReferenceHandler === 'map';
    }
}
exports.ElementMapper = ElementMapper;


/***/ }),

/***/ "./lib/mappers/generic-element.mapper.ts":
/*!***********************************************!*\
  !*** ./lib/mappers/generic-element.mapper.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GenericElementMapper = void 0;
class GenericElementMapper {
    mapElement(response) {
        if (!response) {
            throw Error(`Invalid response for mapping element`);
        }
        const element = response.element;
        return {
            codename: element.codename,
            name: element.name,
            type: element.type,
            options: element.options ? element.options : [],
            taxonomyGroup: element.taxonomy_group
        };
    }
}
exports.GenericElementMapper = GenericElementMapper;


/***/ }),

/***/ "./lib/mappers/index.ts":
/*!******************************!*\
  !*** ./lib/mappers/index.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./element.mapper */ "./lib/mappers/element.mapper.ts"), exports);
__exportStar(__webpack_require__(/*! ./item.mapper */ "./lib/mappers/item.mapper.ts"), exports);
__exportStar(__webpack_require__(/*! ./taxonomy.mapper */ "./lib/mappers/taxonomy.mapper.ts"), exports);
__exportStar(__webpack_require__(/*! ./type.mapper */ "./lib/mappers/type.mapper.ts"), exports);
__exportStar(__webpack_require__(/*! ./generic-element.mapper */ "./lib/mappers/generic-element.mapper.ts"), exports);
__exportStar(__webpack_require__(/*! ./language.mapper */ "./lib/mappers/language.mapper.ts"), exports);
__exportStar(__webpack_require__(/*! ./sync.mapper */ "./lib/mappers/sync.mapper.ts"), exports);


/***/ }),

/***/ "./lib/mappers/item.mapper.ts":
/*!************************************!*\
  !*** ./lib/mappers/item.mapper.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ItemMapper = void 0;
const element_mapper_1 = __webpack_require__(/*! ./element.mapper */ "./lib/mappers/element.mapper.ts");
class ItemMapper {
    constructor(config) {
        this.config = config;
        this.elementMapper = new element_mapper_1.ElementMapper(config);
    }
    /**
     * Maps single item to its proper strongly typed model from the given response
     * @param response Response used to map the item
     * @param queryConfig Query configuration
     */
    mapSingleItemFromResponse(response) {
        const mapResult = this.mapItems({
            mainItems: [response.item],
            linkedItems: Object.values(response.modular_content),
        });
        return {
            item: mapResult.items[0],
            linkedItems: mapResult.linkedItems
        };
    }
    /**
     * Maps multiple items to their strongly typed model from the given  response
     * @param response Response used to map the item
     * @param queryConfig Query configuration
     */
    mapMultipleItemsFromResponse(response) {
        const mapResult = this.mapItems({
            mainItems: response.items,
            linkedItems: Object.values(response.modular_content)
        });
        return mapResult;
    }
    /**
     * Maps item contracts to full models
     */
    mapItems(data) {
        const that = this;
        const processedItems = {};
        const preparedItems = {};
        const processingStartedForCodenames = [];
        const mappedMainItems = [];
        const mappedLinkedItems = {};
        const itemsToResolve = [...data.mainItems, ...data.linkedItems];
        // first prepare reference for all items
        for (const item of itemsToResolve) {
            preparedItems[item.system.codename] = {
                item: this.createContentItem(item),
                rawItem: item
            };
        }
        // then resolve items
        for (const item of data.mainItems) {
            const itemResult = that.mapItem({
                item: preparedItems[item.system.codename],
                processedItems: processedItems,
                preparedItems: preparedItems,
                processingStartedForCodenames: processingStartedForCodenames
            });
            mappedMainItems.push(itemResult.item);
        }
        for (const item of data.linkedItems) {
            const itemResult = that.mapItem({
                item: preparedItems[item.system.codename],
                processedItems: processedItems,
                preparedItems: preparedItems,
                processingStartedForCodenames: processingStartedForCodenames
            });
            mappedLinkedItems[item.system.codename] = itemResult.item;
        }
        return {
            items: mappedMainItems,
            linkedItems: mappedLinkedItems
        };
    }
    /**
     * Maps item contract to full model
     */
    mapItem(data) {
        if (!data.item) {
            throw Error(`Could not map item because its undefined`);
        }
        const result = this.elementMapper.mapElements({
            dataToMap: data.item,
            preparedItems: data.preparedItems,
            processingStartedForCodenames: [],
            processedItems: data.processedItems,
        });
        if (!result) {
            throw Error(`Mapping of content item '${data.item.item.system.codename}' failed`);
        }
        return {
            item: result.item,
            processedItems: result.processedItems,
            preparedItems: result.preparedItems,
            processingStartedForCodenames: result.processingStartedForCodenames
        };
    }
    createContentItem(item) {
        var _a;
        const contentItem = {
            elements: {},
            system: {
                codename: item.system.codename,
                collection: item.system.collection,
                id: item.system.id,
                language: item.system.language,
                lastModified: item.system.last_modified,
                name: item.system.name,
                sitemapLocations: item.system.sitemap_locations,
                type: item.system.type,
                workflowStep: (_a = item.system.workflow_step) !== null && _a !== void 0 ? _a : null
            }
        };
        return contentItem;
    }
}
exports.ItemMapper = ItemMapper;


/***/ }),

/***/ "./lib/mappers/language.mapper.ts":
/*!****************************************!*\
  !*** ./lib/mappers/language.mapper.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LanguageMapper = void 0;
class LanguageMapper {
    mapMultipleLanguages(response) {
        return response.languages.map((language) => {
            return this.mapLanguage(language);
        });
    }
    mapLanguage(language) {
        if (!language) {
            throw Error(`Cannot map language`);
        }
        return {
            system: language.system
        };
    }
}
exports.LanguageMapper = LanguageMapper;


/***/ }),

/***/ "./lib/mappers/sync.mapper.ts":
/*!************************************!*\
  !*** ./lib/mappers/sync.mapper.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyncMapper = void 0;
class SyncMapper {
    mapContentItemDelta(itemDeltaContract) {
        return {
            changeType: itemDeltaContract.change_type,
            codename: itemDeltaContract.codename,
            collection: itemDeltaContract.collection,
            id: itemDeltaContract.id,
            language: itemDeltaContract.language,
            timestamp: itemDeltaContract.timestamp,
            type: itemDeltaContract.type
        };
    }
}
exports.SyncMapper = SyncMapper;


/***/ }),

/***/ "./lib/mappers/taxonomy.mapper.ts":
/*!****************************************!*\
  !*** ./lib/mappers/taxonomy.mapper.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TaxonomyMapper = void 0;
class TaxonomyMapper {
    mapTaxonomy(taxonomySystem, taxonomyTerms) {
        if (!taxonomySystem) {
            throw Error(`Cannot map taxonomy due to missing 'system' property`);
        }
        if (!taxonomyTerms) {
            throw Error(`Cannot map taxonomy due to missing 'terms' property`);
        }
        if (!Array.isArray(taxonomyTerms)) {
            throw Error(`Cannot map terms because no terms array was provided`);
        }
        const mappedSystemAttributes = {
            name: taxonomySystem.name,
            codename: taxonomySystem.codename,
            id: taxonomySystem.id,
            lastModified: taxonomySystem.last_modified
        };
        const mappedTerms = this.mapTaxonomyTerms(taxonomyTerms);
        return {
            system: mappedSystemAttributes,
            terms: mappedTerms
        };
    }
    mapTaxonomies(taxonomies) {
        if (!taxonomies) {
            throw Error(`Cannot map taxonomy due to missing 'taxonomies' property`);
        }
        if (!Array.isArray(taxonomies)) {
            throw Error(`Cannot map taxonomies because the 'taxonomies' property is not an array `);
        }
        const mappedTaxonomies = [];
        taxonomies.forEach((taxonomy) => {
            mappedTaxonomies.push(this.mapTaxonomy(taxonomy.system, taxonomy.terms));
        });
        return mappedTaxonomies;
    }
    /**
     * Recursively map array of taxonomy terms
     * @param termsArray Terms array to map
     */
    mapTaxonomyTerms(termsArray) {
        if (termsArray.length === 0) {
            return [];
        }
        const mappedTermsArray = [];
        termsArray.forEach((terms) => {
            const mappedTerms = {
                codename: terms.codename,
                name: terms.name,
                terms: this.mapTaxonomyTerms(terms.terms)
            };
            mappedTermsArray.push(mappedTerms);
        });
        return mappedTermsArray;
    }
}
exports.TaxonomyMapper = TaxonomyMapper;


/***/ }),

/***/ "./lib/mappers/type.mapper.ts":
/*!************************************!*\
  !*** ./lib/mappers/type.mapper.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeMapper = void 0;
class TypeMapper {
    mapSingleType(response) {
        return this.mapType(response);
    }
    mapMultipleTypes(response) {
        const that = this;
        return response.types.map(function (type) {
            return that.mapType(type);
        });
    }
    mapType(type) {
        if (!type) {
            throw Error(`Cannot map type`);
        }
        if (!type.elements) {
            throw Error(`Cannot map type elements`);
        }
        const system = {
            codename: type.system.codename,
            id: type.system.id,
            name: type.system.name,
            lastModified: type.system.last_modified
        };
        const elements = [];
        const elementNames = Object.getOwnPropertyNames(type.elements);
        elementNames.forEach((elementName) => {
            const typeElement = type.elements[elementName];
            if (!typeElement) {
                throw Error(`Cannot find element '${elementName}' on type '${type}'`);
            }
            // use json property as a codename of the type element
            const elementCodename = elementName;
            // extra properties for certain element types
            const taxonomyGroup = typeElement.taxonomy_group;
            const options = [];
            // some elements can contain options
            const rawOptions = typeElement.options;
            if (rawOptions) {
                if (!Array.isArray(rawOptions)) {
                    throw Error(`Content type 'options' property has to be an array`);
                }
                rawOptions.forEach((rawOption) => {
                    options.push({
                        codename: rawOption.codename,
                        name: rawOption.name
                    });
                });
            }
            elements.push({
                codename: elementCodename,
                taxonomyGroup: taxonomyGroup,
                options: options,
                name: typeElement.name,
                type: typeElement.type
            });
        });
        return {
            elements: elements,
            system: system
        };
    }
}
exports.TypeMapper = TypeMapper;


/***/ }),

/***/ "./lib/models/common/base-responses.ts":
/*!*********************************************!*\
  !*** ./lib/models/common/base-responses.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./lib/models/common/common-models.ts":
/*!********************************************!*\
  !*** ./lib/models/common/common-models.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeliveryError = void 0;
class DeliveryError {
    constructor(data) {
        this.message = data.message;
        this.requestId = data.requestId;
        this.errorCode = data.errorCode;
        this.specificCode = data.specificCode;
    }
}
exports.DeliveryError = DeliveryError;


/***/ }),

/***/ "./lib/models/common/filters.ts":
/*!**************************************!*\
  !*** ./lib/models/common/filters.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Filters = void 0;
var Filters;
(function (Filters) {
    const valueSeparator = ',';
    const defaultValue = '';
    const getParamValueForSystemFilter = (param) => {
        if (!param) {
            return defaultValue;
        }
        if (Array.isArray(param)) {
            let value = '';
            // use [in] filter
            for (let i = 0; i < param.length; i++) {
                value = value + param[i].toString();
                if (i !== param.length - 1) {
                    // append separator if its not last item
                    value = value + valueSeparator;
                }
            }
            return value;
        }
        // single param was given
        return param.toString();
    };
    class TypeFilter {
        constructor(type) {
            this.type = type;
        }
        getParam() {
            if (Array.isArray(this.type)) {
                // multiple types
                return `system.type[in]=${getParamValueForSystemFilter(this.type)}`;
            }
            // single type
            return `system.type=${getParamValueForSystemFilter(this.type)}`;
        }
    }
    Filters.TypeFilter = TypeFilter;
    class CollectionFilter {
        constructor(collection) {
            this.collection = collection;
        }
        getParam() {
            if (Array.isArray(this.collection)) {
                // multiple collections
                return `system.collection[in]=${getParamValueForSystemFilter(this.collection)}`;
            }
            // single collection
            return `system.collection=${getParamValueForSystemFilter(this.collection)}`;
        }
    }
    Filters.CollectionFilter = CollectionFilter;
    class EmptyFilter {
        constructor(element) {
            this.element = element;
        }
        getParam() {
            return `${this.element.trim()}[empty]`;
        }
    }
    Filters.EmptyFilter = EmptyFilter;
    class NotEmptyFilter {
        constructor(element) {
            this.element = element;
        }
        getParam() {
            return `${this.element.trim()}[nempty]`;
        }
    }
    Filters.NotEmptyFilter = NotEmptyFilter;
    class EqualsFilter {
        constructor(element, value) {
            this.element = element;
            this.value = value;
        }
        getParam() {
            return `${this.element.trim()}[eq]=${this.getParamValue()}`;
        }
        getParamValue() {
            if (!this.value) {
                return defaultValue;
            }
            return this.value;
        }
    }
    Filters.EqualsFilter = EqualsFilter;
    class NotEqualsFilter {
        constructor(element, value) {
            this.element = element;
            this.value = value;
        }
        getParam() {
            return `${this.element.trim()}[neq]=${this.getParamValue()}`;
        }
        getParamValue() {
            if (!this.value) {
                return defaultValue;
            }
            return this.value;
        }
    }
    Filters.NotEqualsFilter = NotEqualsFilter;
    class AllFilter {
        constructor(element, values) {
            this.element = element;
            this.values = values;
        }
        getParam() {
            return `${this.element.trim()}[all]=${this.getParamValue()}`;
        }
        getParamValue() {
            if (!this.values || !Array.isArray(this.values)) {
                return defaultValue;
            }
            return this.values.map((m) => m.trim()).join(',');
        }
    }
    Filters.AllFilter = AllFilter;
    class AnyFilter {
        constructor(element, values) {
            this.element = element;
            this.values = values;
        }
        getParam() {
            return `${this.element.trim()}[any]=${this.getParamValue()}`;
        }
        getParamValue() {
            if (!this.values || !Array.isArray(this.values)) {
                return defaultValue;
            }
            return this.values.map((m) => m.trim()).join(',');
        }
    }
    Filters.AnyFilter = AnyFilter;
    class ContainsFilter {
        constructor(element, values) {
            this.element = element;
            this.values = values;
        }
        getParam() {
            return `${this.element.trim()}[contains]=${this.getParamValue()}`;
        }
        getParamValue() {
            if (!this.values || !Array.isArray(this.values)) {
                return defaultValue;
            }
            return this.values.map((m) => m.trim()).join(',');
        }
    }
    Filters.ContainsFilter = ContainsFilter;
    class GreaterThanFilter {
        constructor(element, value) {
            this.element = element;
            this.value = value;
        }
        getParam() {
            return `${this.element.trim()}[gt]=${this.getParamValue()}`;
        }
        getParamValue() {
            if (!this.value) {
                return defaultValue;
            }
            return this.value;
        }
    }
    Filters.GreaterThanFilter = GreaterThanFilter;
    class GreaterThanOrEqualFilter {
        constructor(element, value) {
            this.element = element;
            this.value = value;
        }
        getParam() {
            return `${this.element.trim()}[gte]=${this.getParamValue()}`;
        }
        getParamValue() {
            if (!this.value) {
                return defaultValue;
            }
            return this.value;
        }
    }
    Filters.GreaterThanOrEqualFilter = GreaterThanOrEqualFilter;
    class InFilter {
        constructor(element, values) {
            this.element = element;
            this.values = values;
        }
        getParam() {
            return `${this.element.trim()}[in]=${this.getParamValue()}`;
        }
        getParamValue() {
            if (!this.values || !Array.isArray(this.values)) {
                return defaultValue;
            }
            return this.values
                .map((m) => {
                return m.trim();
            })
                .join(',');
        }
    }
    Filters.InFilter = InFilter;
    class NotInFilter {
        constructor(element, values) {
            this.element = element;
            this.values = values;
        }
        getParam() {
            return `${this.element.trim()}[nin]=${this.getParamValue()}`;
        }
        getParamValue() {
            if (!this.values || !Array.isArray(this.values)) {
                return defaultValue;
            }
            return this.values
                .map((m) => {
                return m.trim();
            })
                .join(',');
        }
    }
    Filters.NotInFilter = NotInFilter;
    class LessThanFilter {
        constructor(element, value) {
            this.element = element;
            this.value = value;
        }
        getParam() {
            return `${this.element.trim()}[lt]=${this.getParamValue()}`;
        }
        getParamValue() {
            if (!this.value) {
                return defaultValue;
            }
            return this.value;
        }
    }
    Filters.LessThanFilter = LessThanFilter;
    class LessThanOrEqualFilter {
        constructor(element, value) {
            this.element = element;
            this.value = value;
        }
        getParam() {
            return `${this.element.trim()}[lte]=${this.getParamValue()}`;
        }
        getParamValue() {
            if (!this.value) {
                return defaultValue;
            }
            return this.value;
        }
    }
    Filters.LessThanOrEqualFilter = LessThanOrEqualFilter;
    class RangeFilter {
        constructor(element, lowerValue, higherValue) {
            this.element = element;
            this.lowerValue = lowerValue;
            this.higherValue = higherValue;
        }
        getParam() {
            return `${this.element.trim()}[range]=${this.getParamValue()}`;
        }
        getParamValue() {
            let lowerVal = defaultValue;
            let higherVal = defaultValue;
            if (this.lowerValue) {
                lowerVal = this.lowerValue.toString();
            }
            if (this.higherValue) {
                higherVal = this.higherValue.toString();
            }
            return `${lowerVal},${higherVal}`;
        }
    }
    Filters.RangeFilter = RangeFilter;
})(Filters = exports.Filters || (exports.Filters = {}));


/***/ }),

/***/ "./lib/models/common/headers.ts":
/*!**************************************!*\
  !*** ./lib/models/common/headers.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.staleContentHeaderName = exports.sdkVersionHeader = exports.waitForLoadingNewContentHeader = exports.continuationTokenHeaderName = void 0;
exports.continuationTokenHeaderName = 'X-Continuation';
exports.waitForLoadingNewContentHeader = 'X-KC-Wait-For-Loading-New-Content';
exports.sdkVersionHeader = 'X-KC-SDKID';
exports.staleContentHeaderName = 'X-Stale-Content';


/***/ }),

/***/ "./lib/models/common/index.ts":
/*!************************************!*\
  !*** ./lib/models/common/index.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./filters */ "./lib/models/common/filters.ts"), exports);
__exportStar(__webpack_require__(/*! ./pagination.class */ "./lib/models/common/pagination.class.ts"), exports);
__exportStar(__webpack_require__(/*! ./parameters */ "./lib/models/common/parameters.ts"), exports);
__exportStar(__webpack_require__(/*! ./sort-order */ "./lib/models/common/sort-order.ts"), exports);
__exportStar(__webpack_require__(/*! ./common-models */ "./lib/models/common/common-models.ts"), exports);
__exportStar(__webpack_require__(/*! ./base-responses */ "./lib/models/common/base-responses.ts"), exports);
__exportStar(__webpack_require__(/*! ./headers */ "./lib/models/common/headers.ts"), exports);


/***/ }),

/***/ "./lib/models/common/pagination.class.ts":
/*!***********************************************!*\
  !*** ./lib/models/common/pagination.class.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./lib/models/common/parameters.ts":
/*!*****************************************!*\
  !*** ./lib/models/common/parameters.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Parameters = void 0;
var Parameters;
(function (Parameters) {
    const defaultValue = '';
    class QueryParameter {
        /**
         * Parameter
         * @constructor
         * @param {string} name - Name of the parameter
         * @param {string} value - Value of the parameter
         */
        constructor(name, value) {
            this.name = name;
            this.value = value;
            if (!name) {
                throw Error(`Name of the parameter is not specified`);
            }
        }
        getParam() {
            return `${this.name}=${this.value}`;
        }
    }
    Parameters.QueryParameter = QueryParameter;
    class ElementsParameter {
        /**
         * Sets elements (projection) so that only certain elements from a content item are returned
         * @constructor
         * @param {string[]} elementCodenames - Array of element codenames to include in response.
         */
        constructor(elementCodenames) {
            this.elementCodenames = elementCodenames;
        }
        getParam() {
            return `elements=${this.getParamValue()}`;
        }
        getParamValue() {
            if (!this.elementCodenames) {
                return defaultValue;
            }
            return this.elementCodenames
                .map((m) => {
                if (!m) {
                    throw Error(`Codename of 'ElementsParameter' cannot be null or empty`);
                }
                return m.trim();
            })
                .join(',');
        }
    }
    Parameters.ElementsParameter = ElementsParameter;
    class LimitParameter {
        /**
         * Limits the number of items that are returned from response
         * @constructor
         * @param {number} limit - Number of elements that will be returned
         */
        constructor(limit) {
            this.limit = limit;
            if (limit <= 0) {
                throw Error(`'LimitParameter' must specify a positive integer`);
            }
        }
        getParam() {
            return `limit=${this.limit}`;
        }
    }
    Parameters.LimitParameter = LimitParameter;
    class IncludeTotalCountParameter {
        /**
         * Adds 'includeTotalCount' query parameter to query
         * @constructor
         */
        constructor() { }
        getParam() {
            return `includeTotalCount=true`;
        }
    }
    Parameters.IncludeTotalCountParameter = IncludeTotalCountParameter;
    class SkipParameter {
        /**
         * Configures response to skip certain number of items
         * @constructor
         * @param {number} skip - Number of content items that will be skipped
         */
        constructor(skip) {
            this.skip = skip;
            if (skip < 0) {
                throw Error(`'SkipParameter' must specify a positive integer number or zero."`);
            }
        }
        getParam() {
            return `skip=${this.skip}`;
        }
    }
    Parameters.SkipParameter = SkipParameter;
    class OrderParameter {
        /**
         * Sorts the response based on given element.
         * @constructor
         * @param {string} element - Element that will be used for sorting (can be both elements.<elementname> or system.<elementname>)
         * @param {SortOrder} sortOrder - Order type (desc/asc). Defaults to 'asc' if SortOrder is null or invalid.
         */
        constructor(element, sortOrder) {
            this.element = element;
            this.sortOrder = sortOrder;
            if (!element) {
                throw Error(`Element specified in 'OrderParameter' is null or empty`);
            }
        }
        getParam() {
            return `order=${this.getParamValue()}`;
        }
        getParamValue() {
            return `${this.element.trim()}[${this.sortOrder}]`;
        }
    }
    Parameters.OrderParameter = OrderParameter;
    class CustomParameter {
        constructor(param) {
            this.param = param;
        }
        getParam() {
            return this.param;
        }
    }
    Parameters.CustomParameter = CustomParameter;
    class DepthParameter {
        /**
         * Configures the depth of the response. Content items might reference another 'linked items' using the Linked items element.
         * Recursively, these linked items can reference another linked items.
         * By default, only one level of linked content is returned.
         * @constructor
         * @param {number} depth - Depth fo the response
         */
        constructor(depth) {
            this.depth = depth;
            if (depth < 0) {
                throw Error(`'DepthParameter' must specify a positive integer or zero`);
            }
        }
        getParam() {
            return `depth=${this.depth}`;
        }
    }
    Parameters.DepthParameter = DepthParameter;
    class LanguageParameter {
        /**
         * Specifies language version to fetch
         * @constructor
         * @param {string} languageCodename - Codename of the language
         */
        constructor(languageCodename) {
            this.languageCodename = languageCodename;
            if (!languageCodename) {
                throw Error(`'LanguageParameter' must specify codename of the language`);
            }
        }
        getParam() {
            return `language=${this.languageCodename}`;
        }
    }
    Parameters.LanguageParameter = LanguageParameter;
})(Parameters = exports.Parameters || (exports.Parameters = {}));


/***/ }),

/***/ "./lib/models/common/sort-order.ts":
/*!*****************************************!*\
  !*** ./lib/models/common/sort-order.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./lib/models/content-type-models.ts":
/*!*******************************************!*\
  !*** ./lib/models/content-type-models.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./lib/models/element-models.ts":
/*!**************************************!*\
  !*** ./lib/models/element-models.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./lib/models/index.ts":
/*!*****************************!*\
  !*** ./lib/models/index.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./common */ "./lib/models/common/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./element-models */ "./lib/models/element-models.ts"), exports);
__exportStar(__webpack_require__(/*! ./item-models */ "./lib/models/item-models.ts"), exports);
__exportStar(__webpack_require__(/*! ./taxonomy-models */ "./lib/models/taxonomy-models.ts"), exports);
__exportStar(__webpack_require__(/*! ./content-type-models */ "./lib/models/content-type-models.ts"), exports);
__exportStar(__webpack_require__(/*! ./language-models */ "./lib/models/language-models.ts"), exports);
__exportStar(__webpack_require__(/*! ./responses */ "./lib/models/responses.ts"), exports);
__exportStar(__webpack_require__(/*! ./sync-models */ "./lib/models/sync-models.ts"), exports);


/***/ }),

/***/ "./lib/models/item-models.ts":
/*!***********************************!*\
  !*** ./lib/models/item-models.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./lib/models/language-models.ts":
/*!***************************************!*\
  !*** ./lib/models/language-models.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./lib/models/responses.ts":
/*!*********************************!*\
  !*** ./lib/models/responses.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./lib/models/sync-models.ts":
/*!***********************************!*\
  !*** ./lib/models/sync-models.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./lib/models/taxonomy-models.ts":
/*!***************************************!*\
  !*** ./lib/models/taxonomy-models.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./lib/parser/implementation/async-browser-parser.class.ts":
/*!*****************************************************************!*\
  !*** ./lib/parser/implementation/async-browser-parser.class.ts ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.asyncBrowserParser = exports.AsyncBrowserParser = void 0;
const parse_models_1 = __webpack_require__(/*! ../parse-models */ "./lib/parser/parse-models.ts");
const parser_configuration_1 = __webpack_require__(/*! ../parser-configuration */ "./lib/parser/parser-configuration.ts");
const parser_helper_1 = __webpack_require__(/*! ../parser.helper */ "./lib/parser/parser.helper.ts");
class AsyncBrowserParser {
    parseAsync(html, mainRichTextElement, resolvers, linkedItems) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.parseInternalAsync(mainRichTextElement, resolvers, html, linkedItems, new parse_models_1.ParsedItemIndexReferenceWrapper(0), null);
        });
    }
    parseInternalAsync(mainRichTextElement, resolvers, html, linkedItems, linkedItemIndex, parentElement) {
        return __awaiter(this, void 0, void 0, function* () {
            const rootElement = this.createWrapperElement(html);
            // get all linked items
            const result = yield this.processRichTextElementAsync(mainRichTextElement, resolvers, rootElement.children, {
                links: [],
                linkedItems: [],
                images: []
            }, linkedItems, linkedItemIndex, parentElement);
            return {
                componentCodenames: result.linkedItems.filter((m) => m.itemType === 'component').map((m) => m.dataCodename),
                linkedItemCodenames: result.linkedItems
                    .filter((m) => m.itemType === 'linkedItem')
                    .map((m) => m.dataCodename),
                result: rootElement.innerHTML
            };
        });
    }
    processRichTextElementAsync(mainRichTextElement, resolvers, htmlCollection, result, linkedItems, linkedItemIndex, parentElement) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!htmlCollection || htmlCollection.length === 0) {
                // there are no more nodes
            }
            else {
                // extract objects
                for (let i = 0; i < htmlCollection.length; i++) {
                    const element = htmlCollection[i];
                    resolvers.elementResolverAsync(parser_helper_1.parserHelper.convertToParserElement(element));
                    const typeAttribute = element.attributes ? element.attributes.getNamedItem('type') : undefined;
                    // process linked items (modular items)
                    if (element.attributes &&
                        typeAttribute &&
                        typeAttribute.value &&
                        typeAttribute.value.toLowerCase() ===
                            parser_configuration_1.parserConfiguration.modularContentElementData.type.toLowerCase()) {
                        const dataCodenameAttribute = element.attributes.getNamedItem(parser_configuration_1.parserConfiguration.modularContentElementData.dataCodename);
                        const dataTypeAttribute = element.attributes.getNamedItem(parser_configuration_1.parserConfiguration.modularContentElementData.dataType);
                        if (!dataTypeAttribute) {
                            throw Error('Missing data type attribute. This is likely an error caused by invalid response.');
                        }
                        const relAttribute = element.attributes.getNamedItem(parser_configuration_1.parserConfiguration.modularContentElementData.relAttribute);
                        let itemType = 'linkedItem';
                        if (relAttribute &&
                            relAttribute.value === parser_configuration_1.parserConfiguration.modularContentElementData.componentRel) {
                            itemType = 'component';
                        }
                        // prepare link item object
                        const linkItemContentObject = {
                            dataCodename: dataCodenameAttribute ? dataCodenameAttribute.value : '',
                            dataType: dataTypeAttribute ? dataTypeAttribute.value : '',
                            itemType: itemType
                        };
                        // replace html
                        const elementParent = element.parentElement;
                        if (!elementParent) {
                            console.warn(`Could not replace linked item '${linkItemContentObject.dataCodename}' of '${linkItemContentObject.dataType}' because parent node is undefined. Please report this error if you are seeing this.`);
                        }
                        else {
                            if (dataTypeAttribute.value === 'item') {
                                // add to result
                                result.linkedItems.push(linkItemContentObject);
                                // resolve linked item
                                yield resolvers.contentItemResolverAsync(parser_helper_1.parserHelper.convertToParserElement(element), linkItemContentObject.dataCodename, linkedItemIndex.index, parser_helper_1.parserHelper.getLinkedItem(linkedItems, linkItemContentObject.dataCodename));
                                // increment index
                                linkedItemIndex.increment();
                            }
                            else {
                                console.warn(`Rich text element contains object with unsupported data type '${dataTypeAttribute.value}'`);
                            }
                        }
                    }
                    // process links
                    else if (element.nodeName.toLowerCase() === parser_configuration_1.parserConfiguration.linkElementData.nodeName.toLowerCase()) {
                        const dataItemIdAttribute = element.attributes.getNamedItem(parser_configuration_1.parserConfiguration.linkElementData.dataItemId);
                        if (dataItemIdAttribute) {
                            const linkObject = {
                                dataItemId: dataItemIdAttribute ? dataItemIdAttribute.value : ''
                            };
                            // add to result
                            result.links.push(linkObject);
                            // get original link text (the one inside <a> tag)
                            const linkText = element.innerHTML;
                            yield resolvers.urlResolverAsync(parser_helper_1.parserHelper.convertToParserElement(element), linkObject.dataItemId, linkText, parser_helper_1.parserHelper.tryGetLink(mainRichTextElement, linkedItems, linkObject.dataItemId));
                        }
                    }
                    // process images
                    else if (element.nodeName.toLowerCase() === parser_configuration_1.parserConfiguration.imageElementData.nodeName.toLowerCase()) {
                        const dataImageIdAttribute = element.attributes.getNamedItem(parser_configuration_1.parserConfiguration.imageElementData.dataImageId);
                        // continue only if data image id is present. There could be regular img tags included
                        if (dataImageIdAttribute) {
                            const imageObj = {
                                imageId: dataImageIdAttribute.value
                            };
                            result.images.push(imageObj);
                            // resolve image
                            yield resolvers.imageResolverAsync(parser_helper_1.parserHelper.convertToParserElement(element), imageObj.imageId, parser_helper_1.parserHelper.tryGetImage(mainRichTextElement, linkedItems, imageObj.imageId));
                        }
                    }
                    else {
                        // process generic elements
                        yield resolvers.genericElementResolverAsync(parser_helper_1.parserHelper.convertToParserElement(element));
                    }
                    // recursively process child nodes
                    if (element.children && element.children.length > 0) {
                        yield this.processRichTextElementAsync(mainRichTextElement, resolvers, element.children, result, linkedItems, linkedItemIndex, parentElement);
                    }
                }
            }
            return result;
        });
    }
    createWrapperElement(html) {
        const element = document.createElement(parser_configuration_1.parserConfiguration.linkedItemWrapperElem);
        element.innerHTML = html;
        return element;
    }
}
exports.AsyncBrowserParser = AsyncBrowserParser;
exports.asyncBrowserParser = new AsyncBrowserParser();


/***/ }),

/***/ "./lib/parser/implementation/browser-parser.class.ts":
/*!***********************************************************!*\
  !*** ./lib/parser/implementation/browser-parser.class.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.browserParser = exports.BrowserParser = void 0;
const parse_models_1 = __webpack_require__(/*! ../parse-models */ "./lib/parser/parse-models.ts");
const parser_configuration_1 = __webpack_require__(/*! ../parser-configuration */ "./lib/parser/parser-configuration.ts");
const parser_helper_1 = __webpack_require__(/*! ../parser.helper */ "./lib/parser/parser.helper.ts");
class BrowserParser {
    parse(html, mainRichTextElement, resolvers, linkedItems) {
        return this.parseInternal(mainRichTextElement, resolvers, html, linkedItems, new parse_models_1.ParsedItemIndexReferenceWrapper(0), null);
    }
    parseInternal(mainRichTextElement, resolvers, html, linkedItems, linkedItemIndex, parentElement) {
        const rootElement = this.createWrapperElement(html);
        // get all linked items
        const result = this.processRichTextElement(mainRichTextElement, resolvers, rootElement.children, {
            links: [],
            linkedItems: [],
            images: []
        }, linkedItems, linkedItemIndex, parentElement);
        return {
            componentCodenames: result.linkedItems.filter((m) => m.itemType === 'component').map((m) => m.dataCodename),
            linkedItemCodenames: result.linkedItems
                .filter((m) => m.itemType === 'linkedItem')
                .map((m) => m.dataCodename),
            result: rootElement.innerHTML
        };
    }
    processRichTextElement(mainRichTextElement, resolvers, htmlCollection, result, linkedItems, linkedItemIndex, parentElement) {
        if (!htmlCollection || htmlCollection.length === 0) {
            // there are no more nodes
        }
        else {
            // extract objects
            for (let i = 0; i < htmlCollection.length; i++) {
                const element = htmlCollection[i];
                resolvers.elementResolver(parser_helper_1.parserHelper.convertToParserElement(element));
                const typeAttribute = element.attributes ? element.attributes.getNamedItem('type') : undefined;
                // process linked items (modular items)
                if (element.attributes &&
                    typeAttribute &&
                    typeAttribute.value &&
                    typeAttribute.value.toLowerCase() ===
                        parser_configuration_1.parserConfiguration.modularContentElementData.type.toLowerCase()) {
                    const dataCodenameAttribute = element.attributes.getNamedItem(parser_configuration_1.parserConfiguration.modularContentElementData.dataCodename);
                    const dataTypeAttribute = element.attributes.getNamedItem(parser_configuration_1.parserConfiguration.modularContentElementData.dataType);
                    if (!dataTypeAttribute) {
                        throw Error('Missing data type attribute. This is likely an error caused by invalid response.');
                    }
                    const relAttribute = element.attributes.getNamedItem(parser_configuration_1.parserConfiguration.modularContentElementData.relAttribute);
                    let itemType = 'linkedItem';
                    if (relAttribute &&
                        relAttribute.value === parser_configuration_1.parserConfiguration.modularContentElementData.componentRel) {
                        itemType = 'component';
                    }
                    // prepare link item object
                    const linkItemContentObject = {
                        dataCodename: dataCodenameAttribute ? dataCodenameAttribute.value : '',
                        dataType: dataTypeAttribute ? dataTypeAttribute.value : '',
                        itemType: itemType
                    };
                    const elementParent = element.parentElement;
                    if (!elementParent) {
                        console.warn(`Could not replace linked item '${linkItemContentObject.dataCodename}' of '${linkItemContentObject.dataType}' because parent node is undefined. Please report this error if you are seeing this.`);
                    }
                    else {
                        if (dataTypeAttribute.value === 'item') {
                            // add to result
                            result.linkedItems.push(linkItemContentObject);
                            // resolve linked item
                            resolvers.contentItemResolver(parser_helper_1.parserHelper.convertToParserElement(element), linkItemContentObject.dataCodename, linkedItemIndex.index, parser_helper_1.parserHelper.getLinkedItem(linkedItems, linkItemContentObject.dataCodename));
                            // increment index
                            linkedItemIndex.increment();
                        }
                        else {
                            console.warn(`Rich text element contains object with unsupported data type '${dataTypeAttribute.value}'`);
                        }
                    }
                }
                // process links
                else if (element.nodeName.toLowerCase() === parser_configuration_1.parserConfiguration.linkElementData.nodeName.toLowerCase()) {
                    const dataItemIdAttribute = element.attributes.getNamedItem(parser_configuration_1.parserConfiguration.linkElementData.dataItemId);
                    if (dataItemIdAttribute) {
                        const linkObject = {
                            dataItemId: dataItemIdAttribute ? dataItemIdAttribute.value : ''
                        };
                        // add to result
                        result.links.push(linkObject);
                        // get original link text (the one inside <a> tag)
                        const linkText = element.innerHTML;
                        resolvers.urlResolver(parser_helper_1.parserHelper.convertToParserElement(element), linkObject.dataItemId, linkText, parser_helper_1.parserHelper.tryGetLink(mainRichTextElement, linkedItems, linkObject.dataItemId));
                    }
                }
                // process images
                else if (element.nodeName.toLowerCase() === parser_configuration_1.parserConfiguration.imageElementData.nodeName.toLowerCase()) {
                    const dataImageIdAttribute = element.attributes.getNamedItem(parser_configuration_1.parserConfiguration.imageElementData.dataImageId);
                    // continue only if data image id is present. There could be regular img tags included
                    if (dataImageIdAttribute) {
                        const imageObj = {
                            imageId: dataImageIdAttribute.value
                        };
                        result.images.push(imageObj);
                        // resolve image
                        resolvers.imageResolver(parser_helper_1.parserHelper.convertToParserElement(element), imageObj.imageId, parser_helper_1.parserHelper.tryGetImage(mainRichTextElement, linkedItems, imageObj.imageId));
                    }
                }
                else {
                    // process generic elements
                    resolvers.genericElementResolver(parser_helper_1.parserHelper.convertToParserElement(element));
                }
                // recursively process child nodes
                if (element.children && element.children.length > 0) {
                    this.processRichTextElement(mainRichTextElement, resolvers, element.children, result, linkedItems, linkedItemIndex, parentElement);
                }
            }
        }
        return result;
    }
    createWrapperElement(html) {
        const element = document.createElement(parser_configuration_1.parserConfiguration.linkedItemWrapperElem);
        element.innerHTML = html;
        return element;
    }
}
exports.BrowserParser = BrowserParser;
exports.browserParser = new BrowserParser();


/***/ }),

/***/ "./lib/parser/index.ts":
/*!*****************************!*\
  !*** ./lib/parser/index.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./parse-models */ "./lib/parser/parse-models.ts"), exports);
__exportStar(__webpack_require__(/*! ./parser-configuration */ "./lib/parser/parser-configuration.ts"), exports);
__exportStar(__webpack_require__(/*! ./parser.helper */ "./lib/parser/parser.helper.ts"), exports);
__exportStar(__webpack_require__(/*! ./implementation/async-browser-parser.class */ "./lib/parser/implementation/async-browser-parser.class.ts"), exports);
__exportStar(__webpack_require__(/*! ./implementation/browser-parser.class */ "./lib/parser/implementation/browser-parser.class.ts"), exports);


/***/ }),

/***/ "./lib/parser/parse-models.ts":
/*!************************************!*\
  !*** ./lib/parser/parse-models.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ParsedItemIndexReferenceWrapper = void 0;
/**
 * This class as a wrapper is required so we can pass
 * index as a reference and not a value
 */
class ParsedItemIndexReferenceWrapper {
    constructor(index) {
        this.index = index;
    }
    increment() {
        this.index++;
    }
}
exports.ParsedItemIndexReferenceWrapper = ParsedItemIndexReferenceWrapper;


/***/ }),

/***/ "./lib/parser/parser-configuration.ts":
/*!********************************************!*\
  !*** ./lib/parser/parser-configuration.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parserConfiguration = void 0;
exports.parserConfiguration = {
    linkedItemWrapperElem: 'div',
    modularContentElementData: {
        type: 'application/kenticocloud',
        dataType: 'data-type',
        dataCodename: 'data-codename',
        relAttribute: 'data-rel',
        componentRel: 'component'
    },
    linkElementData: {
        nodeName: 'a',
        dataItemId: 'data-item-id',
    },
    imageElementData: {
        nodeName: 'img',
        dataImageId: 'data-image-id',
        srcAttribute: 'src'
    },
    resolvedLinkedItemIndexAttribute: 'data-sdk-item-index',
    resolvedAttribute: 'data-sdk-resolved'
};


/***/ }),

/***/ "./lib/parser/parser.helper.ts":
/*!*************************************!*\
  !*** ./lib/parser/parser.helper.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parserHelper = exports.ParserHelper = void 0;
const elements_1 = __webpack_require__(/*! ../elements */ "./lib/elements/index.ts");
class ParserHelper {
    constructor() {
        this.sdkResolvedAttributeName = 'data-sdk-resolved';
    }
    getLinkedItem(linkedItems, itemCodename) {
        if (!linkedItems) {
            return undefined;
        }
        return linkedItems.find((m) => m.system.codename === itemCodename);
    }
    tryGetImage(inputElement, linkedItems, imageId) {
        const elementImage = inputElement.images.find((m) => m.imageId === imageId);
        if (elementImage) {
            return elementImage;
        }
        // try to find image in all linked items
        if (linkedItems) {
            for (const linkedItem of linkedItems) {
                for (const elementKey of Object.keys(linkedItem.elements)) {
                    const element = linkedItem.elements[elementKey];
                    if (element.type === elements_1.ElementType.RichText) {
                        const richTextElement = element;
                        const richTextElementImage = richTextElement.images.find((m) => m.imageId === imageId);
                        if (richTextElementImage) {
                            return richTextElementImage;
                        }
                    }
                }
            }
        }
        return undefined;
    }
    tryGetLink(inputElement, linkedItems, linkId) {
        const elementLink = inputElement.links.find((m) => m.linkId === linkId);
        if (elementLink) {
            return elementLink;
        }
        // try to find link in all linked items
        if (linkedItems) {
            for (const linkedItem of linkedItems) {
                for (const elementKey of Object.keys(linkedItem.elements)) {
                    const element = linkedItem.elements[elementKey];
                    if (element.type === elements_1.ElementType.RichText) {
                        const richTextElement = element;
                        const richTextElementLink = richTextElement.links.find((m) => m.linkId === linkId);
                        if (richTextElementLink) {
                            return richTextElementLink;
                        }
                    }
                }
            }
        }
        return undefined;
    }
    convertToParserElement(element) {
        const attributes = [];
        for (let i = 0; i < element.attributes.length; i++) {
            const attribute = element.attributes[i];
            attributes.push({
                name: attribute.name,
                value: attribute.value
            });
        }
        return {
            tag: element.tagName,
            setAttribute: (attributeName, attributeValue) => {
                const attribute = element.attributes.getNamedItem(attributeName);
                if (attribute) {
                    attribute.value = attributeValue !== null && attributeValue !== void 0 ? attributeValue : '';
                }
                else {
                    element.setAttribute(attributeName, attributeValue !== null && attributeValue !== void 0 ? attributeValue : '');
                }
            },
            setInnerHtml: (newHtml) => (element.innerHTML = newHtml),
            setOuterHtml: (newHtml) => (element.outerHTML = newHtml),
            html: element.innerHTML,
            text: element.textContent ? element.textContent : undefined,
            attributes: attributes,
            parentElement: element.parentElement ? this.convertToParserElement(element.parentElement) : undefined,
            sourceElement: element
        };
    }
}
exports.ParserHelper = ParserHelper;
exports.parserHelper = new ParserHelper();


/***/ }),

/***/ "./lib/query/common/base-item-listing-query.class.ts":
/*!***********************************************************!*\
  !*** ./lib/query/common/base-item-listing-query.class.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseItemListingQuery = void 0;
const models_1 = __webpack_require__(/*! ../../models */ "./lib/models/index.ts");
const base_listing_query_class_1 = __webpack_require__(/*! ./base-listing-query.class */ "./lib/query/common/base-listing-query.class.ts");
class BaseItemListingQuery extends base_listing_query_class_1.BaseListingQuery {
    constructor(config, queryService) {
        super(config, queryService);
        this.config = config;
        this.queryService = queryService;
    }
    /**
     * Empty filter condition
     * @param element Element with empty value
     */
    emptyFilter(element) {
        this.parameters.push(new models_1.Filters.EmptyFilter(element));
        return this;
    }
    /**
     * Not empty filter condition
     * @param element Element with non-empty value
     */
    notEmptyFilter(element) {
        this.parameters.push(new models_1.Filters.NotEmptyFilter(element));
        return this;
    }
    /**
     * Equals filter condition
     * @param element Element to filter. Example: 'elements.movie'
     * @param value Value to match. Example: 'Kingsman'
     */
    equalsFilter(element, value) {
        this.parameters.push(new models_1.Filters.EqualsFilter(element, value));
        return this;
    }
    /**
     * Not equals filter condition
     * @param element Element to filter. Example: 'elements.movie'
     * @param value Value to match. Example: 'Kingsman'
     */
    notEqualsFilter(element, value) {
        this.parameters.push(new models_1.Filters.NotEqualsFilter(element, value));
        return this;
    }
    /**
     * All filter
     * @param element Element to filter.
     * @param values Values
     */
    allFilter(element, values) {
        this.parameters.push(new models_1.Filters.AllFilter(element, values));
        return this;
    }
    /**
     * Any filter
     * @param element Element to filter.
     * @param values Values
     */
    anyFilter(element, values) {
        this.parameters.push(new models_1.Filters.AnyFilter(element, values));
        return this;
    }
    /**
     * Contains filter
     * @param element Element to filter.
     * @param values Values
     */
    containsFilter(element, values) {
        this.parameters.push(new models_1.Filters.ContainsFilter(element, values));
        return this;
    }
    /**
     * Greater then filter
     * @param element Element to filter.
     * @param value Value
     */
    greaterThanFilter(element, value) {
        this.parameters.push(new models_1.Filters.GreaterThanFilter(element, value));
        return this;
    }
    /**
     * Greater then or equals filter
     * @param element Element to filter.
     * @param value Value
     */
    greaterThanOrEqualFilter(element, value) {
        this.parameters.push(new models_1.Filters.GreaterThanOrEqualFilter(element, value));
        return this;
    }
    /**
     * In filter
     * @param element Element to filter.
     * @param values Values
     */
    inFilter(element, values) {
        this.parameters.push(new models_1.Filters.InFilter(element, values));
        return this;
    }
    /**
     * Not in filter
     * @param element Element to filter.
     * @param values Values
     */
    notInFilter(element, values) {
        this.parameters.push(new models_1.Filters.NotInFilter(element, values));
        return this;
    }
    /**
     * Less then filter
     * @param element Element to filter.
     * @param value Value
     */
    lessThanFilter(element, value) {
        this.parameters.push(new models_1.Filters.LessThanFilter(element, value));
        return this;
    }
    /**
     * @param element Element to filter.
     * @param value Value
     */
    lessThanOrEqualFilter(element, value) {
        this.parameters.push(new models_1.Filters.LessThanOrEqualFilter(element, value));
        return this;
    }
    /**
     * @param element Element to filter.
     * @param lowerValue Lower value of range (e.g. 2)
     * @param higherValue Higher value of range (e.g. 10)
     */
    rangeFilter(element, lowerValue, higherValue) {
        this.parameters.push(new models_1.Filters.RangeFilter(element, lowerValue, higherValue));
        return this;
    }
    /**
     * Limits the number of items returned by query
     * @param limit Number of items to load
     */
    limitParameter(limit) {
        this.parameters.push(new models_1.Parameters.LimitParameter(limit));
        return this;
    }
    /**
     * Orders query based on given element and sort order
     * @param element Element by which to order
     * @param sortOrder Asc/Desc order type
     */
    orderParameter(element, sortOrder) {
        this.parameters.push(new models_1.Parameters.OrderParameter(element, sortOrder));
        return this;
    }
    /**
     * Sets descending order on given element
     * @param element Element by which to order
     */
    orderByDescending(element) {
        this.parameters.push(new models_1.Parameters.OrderParameter(element, 'desc'));
        return this;
    }
    /**
     * Sets Ascending order on given element
     * @param element Element by which to order
     */
    orderByAscending(element) {
        this.parameters.push(new models_1.Parameters.OrderParameter(element, 'asc'));
        return this;
    }
    /**
     * Skips the selected number of items
     * @param skip Number of items to skip
     */
    skipParameter(skip) {
        this.parameters.push(new models_1.Parameters.SkipParameter(skip));
        return this;
    }
}
exports.BaseItemListingQuery = BaseItemListingQuery;


/***/ }),

/***/ "./lib/query/common/base-listing-query.class.ts":
/*!******************************************************!*\
  !*** ./lib/query/common/base-listing-query.class.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseListingQuery = void 0;
const models_1 = __webpack_require__(/*! ../../models */ "./lib/models/index.ts");
const base_query_class_1 = __webpack_require__(/*! ./base-query.class */ "./lib/query/common/base-query.class.ts");
class BaseListingQuery extends base_query_class_1.BaseQuery {
    constructor(config, queryService) {
        super(config, queryService);
        this.config = config;
        this.queryService = queryService;
    }
    /**
     * Sets continuation token header
     */
    withContinuationToken(token) {
        var _a;
        // remove previous continuation token if there is any
        let queryHeaders = (_a = this._queryConfig.customHeaders) !== null && _a !== void 0 ? _a : [];
        queryHeaders = queryHeaders.filter((m) => m.header !== models_1.continuationTokenHeaderName);
        this._queryConfig.customHeaders = queryHeaders;
        this.withHeaders([
            {
                header: models_1.continuationTokenHeaderName,
                value: token
            }
        ]);
        return this;
    }
    /**
     * Query to get all items. Uses paging data and may execute multiple HTTP requests depending on number of items
     */
    toAllPromise(queryAllConfig) {
        return this.queryService.getListAllResponse({
            page: 1,
            listQueryConfig: queryAllConfig,
            allResponseFactory: (items, responses) => {
                const response = this.allResponseFactory(items, responses);
                return {
                    data: response,
                    responses: responses
                };
            },
            getResponse: (nextPageUrl, continuationToken) => {
                let query = this;
                if (nextPageUrl) {
                    query = this.withCustomUrl(nextPageUrl);
                }
                if (continuationToken) {
                    query = this.withContinuationToken(continuationToken);
                }
                return query.toPromise();
            }
        });
    }
}
exports.BaseListingQuery = BaseListingQuery;


/***/ }),

/***/ "./lib/query/common/base-query.class.ts":
/*!**********************************************!*\
  !*** ./lib/query/common/base-query.class.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseQuery = void 0;
const models_1 = __webpack_require__(/*! ../../models */ "./lib/models/index.ts");
class BaseQuery {
    constructor(config, queryService) {
        this.config = config;
        this.queryService = queryService;
        this.parameters = [];
    }
    /**
     * Adds custom parameter to query
     * @param name Name of parameter
     * @param value Value of parameter
     */
    withCustomParameter(name, value) {
        this.parameters.push(new models_1.Parameters.QueryParameter(name, value));
        return this;
    }
    /**
     * Adds parameter to query
     * @param name Name of parameter
     * @param value Value of parameter
     */
    withParameter(parameter) {
        this.parameters.push(parameter);
        return this;
    }
    /**
     * Adds parameters to query
     * @param parameters Array of parameters
     */
    withParameters(parameters) {
        this.parameters.push(...parameters);
        return this;
    }
    /**
     * Gets headers used by this query
     */
    getHeaders() {
        return this.queryService.getHeaders(this._queryConfig, []);
    }
    /**
     * Sets request headers
     */
    withHeaders(headers) {
        var _a;
        const queryHeaders = (_a = this._queryConfig.customHeaders) !== null && _a !== void 0 ? _a : [];
        queryHeaders.push(...headers);
        this._queryConfig.customHeaders = queryHeaders;
        return this;
    }
    /**
     * Sets request header
     */
    withHeader(header) {
        var _a;
        const queryHeaders = (_a = this._queryConfig.customHeaders) !== null && _a !== void 0 ? _a : [];
        queryHeaders.push(header);
        this._queryConfig.customHeaders = queryHeaders;
        return this;
    }
    /**
     * Sets custom URL of request (overrides default URL of the query)
     */
    withCustomUrl(url) {
        this.customUrl = url;
        return this;
    }
    /**
     * Gets all query parameter currently applied to query
     */
    getParameters() {
        return this.parameters;
    }
    /**
     * Used to configure query
     * @param queryConfig Query configuration
     */
    queryConfig(queryConfig) {
        this._queryConfig = queryConfig;
        return this;
    }
    resolveUrlInternal(action) {
        var _a;
        // use custom URL if user specified it
        if (this.customUrl) {
            return this.customUrl;
        }
        // use original url
        return this.queryService.getUrl(action, (_a = this._queryConfig) !== null && _a !== void 0 ? _a : {}, this.getParameters());
    }
    processDefaultLanguageParameter() {
        // add default language if none is specified && default language is specified globally
        if (this.config.defaultLanguage) {
            const languageParameter = this.getParameters().find((m) => m.getParam() === 'language');
            if (!languageParameter) {
                // language parameter was not specified in query, use globally defined language
                this.parameters.push(new models_1.Parameters.LanguageParameter(this.config.defaultLanguage));
            }
        }
    }
}
exports.BaseQuery = BaseQuery;


/***/ }),

/***/ "./lib/query/element/element-query.class.ts":
/*!**************************************************!*\
  !*** ./lib/query/element/element-query.class.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ElementQuery = void 0;
const base_query_class_1 = __webpack_require__(/*! ../common/base-query.class */ "./lib/query/common/base-query.class.ts");
class ElementQuery extends base_query_class_1.BaseQuery {
    constructor(config, queryService, typeCodename, elementCodename) {
        super(config, queryService);
        this.config = config;
        this.queryService = queryService;
        this.typeCodename = typeCodename;
        this.elementCodename = elementCodename;
        this._queryConfig = {};
        if (!typeCodename) {
            throw Error(`Codename of the type has to be provided`);
        }
        if (!elementCodename) {
            throw Error(`Codename of the element has to be provided`);
        }
    }
    toPromise() {
        var _a;
        return this.queryService.getElementAsync(this.getUrl(), (_a = this._queryConfig) !== null && _a !== void 0 ? _a : {});
    }
    getUrl() {
        return super.resolveUrlInternal(`/types/${this.typeCodename}/elements/${this.elementCodename}`);
    }
    map(json) {
        return this.queryService.mappingService.viewContentTypeElementResponse(json);
    }
}
exports.ElementQuery = ElementQuery;


/***/ }),

/***/ "./lib/query/index.ts":
/*!****************************!*\
  !*** ./lib/query/index.ts ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./common/base-query.class */ "./lib/query/common/base-query.class.ts"), exports);
__exportStar(__webpack_require__(/*! ./element/element-query.class */ "./lib/query/element/element-query.class.ts"), exports);
__exportStar(__webpack_require__(/*! ./item/multiple-items-query.class */ "./lib/query/item/multiple-items-query.class.ts"), exports);
__exportStar(__webpack_require__(/*! ./item/single-item-query.class */ "./lib/query/item/single-item-query.class.ts"), exports);
__exportStar(__webpack_require__(/*! ./taxonomy/taxonomies-query.class */ "./lib/query/taxonomy/taxonomies-query.class.ts"), exports);
__exportStar(__webpack_require__(/*! ./taxonomy/taxonomy-query.class */ "./lib/query/taxonomy/taxonomy-query.class.ts"), exports);
__exportStar(__webpack_require__(/*! ./type/multiple-type-query.class */ "./lib/query/type/multiple-type-query.class.ts"), exports);
__exportStar(__webpack_require__(/*! ./type/single-type-query.class */ "./lib/query/type/single-type-query.class.ts"), exports);
__exportStar(__webpack_require__(/*! ./items-feed/items-feed-query.class */ "./lib/query/items-feed/items-feed-query.class.ts"), exports);
__exportStar(__webpack_require__(/*! ./language/languages-query.class */ "./lib/query/language/languages-query.class.ts"), exports);
__exportStar(__webpack_require__(/*! ./sync/initialize-sync-query.class */ "./lib/query/sync/initialize-sync-query.class.ts"), exports);
__exportStar(__webpack_require__(/*! ./sync/sync-changes-query.class */ "./lib/query/sync/sync-changes-query.class.ts"), exports);


/***/ }),

/***/ "./lib/query/item/multiple-items-query.class.ts":
/*!******************************************************!*\
  !*** ./lib/query/item/multiple-items-query.class.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MultipleItemsQuery = void 0;
const models_1 = __webpack_require__(/*! ../../models */ "./lib/models/index.ts");
const base_item_listing_query_class_1 = __webpack_require__(/*! ../common/base-item-listing-query.class */ "./lib/query/common/base-item-listing-query.class.ts");
class MultipleItemsQuery extends base_item_listing_query_class_1.BaseItemListingQuery {
    constructor(config, queryService) {
        super(config, queryService);
        this.config = config;
        this.queryService = queryService;
        this._queryConfig = {};
    }
    /**
     * Adds information about the total number of content items matching your query.
     * When set to true, the pagination object returned in the API response contains
     * an additional total_count property.
     */
    includeTotalCountParameter() {
        this.parameters.push(new models_1.Parameters.IncludeTotalCountParameter());
        return this;
    }
    /**
     * Gets only item of given type
     * @param type Codename of type to get
     */
    type(type) {
        this.parameters.push(new models_1.Filters.TypeFilter(type));
        return this;
    }
    /**
     * Gets items of given types (logical or)
     * I.e. get items of either 'Actor' or 'Movie' type
     * @param types Types to get
     */
    types(types) {
        this.parameters.push(new models_1.Filters.TypeFilter(types));
        return this;
    }
    /**
     * Gets only item from given collection
     * @param collection Codename of collection to get
     */
    collection(collection) {
        this.parameters.push(new models_1.Filters.CollectionFilter(collection));
        return this;
    }
    /**
     * Gets items from given collections (logical or)
     * I.e. get items of either 'default' or 'christmas-campaign' collection
     * @param collections Collections to get
     */
    collections(collections) {
        this.parameters.push(new models_1.Filters.CollectionFilter(collections));
        return this;
    }
    /**
     * Indicates depth of query that affects loading of nested linked items.
     * @param depth Depth of the query (> 0)
     */
    depthParameter(depth) {
        this.parameters.push(new models_1.Parameters.DepthParameter(depth));
        return this;
    }
    /**
     * Language codename
     * @param languageCodename Codename of the language
     */
    languageParameter(languageCodename) {
        this.parameters.push(new models_1.Parameters.LanguageParameter(languageCodename));
        return this;
    }
    /**
     * Used to limit the number of elements returned by query.
     * @param elementCodenames Array of element codenames to fetch
     */
    elementsParameter(elementCodenames) {
        this.parameters.push(new models_1.Parameters.ElementsParameter(elementCodenames));
        return this;
    }
    toPromise() {
        var _a;
        return this.queryService.getMultipleItems(this.getUrl(), (_a = this._queryConfig) !== null && _a !== void 0 ? _a : {});
    }
    getUrl() {
        const action = '/items';
        // add default language is necessry
        this.processDefaultLanguageParameter();
        return super.resolveUrlInternal(action);
    }
    map(json) {
        return this.queryService.mappingService.listContentItemsResponse(json);
    }
    allResponseFactory(items, responses) {
        return {
            items: items,
            responses: responses
        };
    }
}
exports.MultipleItemsQuery = MultipleItemsQuery;


/***/ }),

/***/ "./lib/query/item/single-item-query.class.ts":
/*!***************************************************!*\
  !*** ./lib/query/item/single-item-query.class.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SingleItemQuery = void 0;
const models_1 = __webpack_require__(/*! ../../models */ "./lib/models/index.ts");
const base_query_class_1 = __webpack_require__(/*! ../common/base-query.class */ "./lib/query/common/base-query.class.ts");
class SingleItemQuery extends base_query_class_1.BaseQuery {
    constructor(config, queryService, codename) {
        super(config, queryService);
        this.config = config;
        this.queryService = queryService;
        this.codename = codename;
        this._queryConfig = {};
        if (!codename) {
            throw Error(`'codename' has to be configured for 'SingleItemQuery' query`);
        }
    }
    /**
     * Indicates depth of query that affects loading of nested linked items.
     * @param depth Depth of the query (> 0)
     */
    depthParameter(depth) {
        this.parameters.push(new models_1.Parameters.DepthParameter(depth));
        return this;
    }
    /**
     * Used to configure query
     * @param queryConfig Query configuration
     */
    queryConfig(queryConfig) {
        this._queryConfig = queryConfig;
        return this;
    }
    /**
     * Language codename
     * @param languageCodename Codename of the language
     */
    languageParameter(languageCodename) {
        this.parameters.push(new models_1.Parameters.LanguageParameter(languageCodename));
        return this;
    }
    /**
     * Used to limit the number of elements returned by query.
     * @param elementCodenames Array of element codenames to fetch
     */
    elementsParameter(elementCodenames) {
        this.parameters.push(new models_1.Parameters.ElementsParameter(elementCodenames));
        return this;
    }
    toPromise() {
        var _a;
        return this.queryService.getSingleItemAsync(this.getUrl(), (_a = this._queryConfig) !== null && _a !== void 0 ? _a : {});
    }
    getUrl() {
        const action = '/items/' + this.codename;
        // add default language is necessry
        this.processDefaultLanguageParameter();
        return super.resolveUrlInternal(action);
    }
    map(json) {
        return this.queryService.mappingService.viewContentItemResponse(json);
    }
}
exports.SingleItemQuery = SingleItemQuery;


/***/ }),

/***/ "./lib/query/items-feed/items-feed-query.class.ts":
/*!********************************************************!*\
  !*** ./lib/query/items-feed/items-feed-query.class.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ItemsFeedQuery = void 0;
const models_1 = __webpack_require__(/*! ../../models */ "./lib/models/index.ts");
const base_item_listing_query_class_1 = __webpack_require__(/*! ../common/base-item-listing-query.class */ "./lib/query/common/base-item-listing-query.class.ts");
class ItemsFeedQuery extends base_item_listing_query_class_1.BaseItemListingQuery {
    constructor(config, queryService) {
        super(config, queryService);
        this.config = config;
        this.queryService = queryService;
        this._queryConfig = {};
    }
    /**
     * Gets only item of given type
     * @param type Codename of type to get
     */
    type(type) {
        this.parameters.push(new models_1.Filters.TypeFilter(type));
        return this;
    }
    /**
     * Gets items of given types (logical or)
     * I.e. get items of either 'Actor' or 'Movie' type
     * @param types Types to get
     */
    types(types) {
        this.parameters.push(new models_1.Filters.TypeFilter(types));
        return this;
    }
    /**
     * Gets only item from given collection
     * @param collection Codename of collection to get
     */
    collection(collection) {
        this.parameters.push(new models_1.Filters.CollectionFilter(collection));
        return this;
    }
    /**
     * Gets items from given collections (logical or)
     * I.e. get items of either 'default' or 'christmas-campaign' collection
     * @param collections Collections to get
     */
    collections(collections) {
        this.parameters.push(new models_1.Filters.CollectionFilter(collections));
        return this;
    }
    /**
     * Language codename
     * @param languageCodename Codename of the language
     */
    languageParameter(languageCodename) {
        this.parameters.push(new models_1.Parameters.LanguageParameter(languageCodename));
        return this;
    }
    /**
     * Used to limit the number of elements returned by query.
     * @param elementCodenames Array of element codenames to fetch
     */
    elementsParameter(elementCodenames) {
        this.parameters.push(new models_1.Parameters.ElementsParameter(elementCodenames));
        return this;
    }
    toPromise() {
        var _a;
        return this.queryService.getItemsFeed(this.getUrl(), (_a = this._queryConfig) !== null && _a !== void 0 ? _a : {});
    }
    getUrl() {
        const action = '/items-feed';
        // add default language is necessary
        this.processDefaultLanguageParameter();
        return super.resolveUrlInternal(action);
    }
    /**
     * Used to configure query
     * @param queryConfig Query configuration
     */
    queryConfig(queryConfig) {
        this._queryConfig = queryConfig;
        return this;
    }
    map(json) {
        return this.queryService.mappingService.itemsFeedResponse(json);
    }
    allResponseFactory(items, responses) {
        return {
            items: items,
            responses: responses
        };
    }
}
exports.ItemsFeedQuery = ItemsFeedQuery;


/***/ }),

/***/ "./lib/query/language/languages-query.class.ts":
/*!*****************************************************!*\
  !*** ./lib/query/language/languages-query.class.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LanguagesQuery = void 0;
const models_1 = __webpack_require__(/*! ../../models */ "./lib/models/index.ts");
const base_listing_query_class_1 = __webpack_require__(/*! ../common/base-listing-query.class */ "./lib/query/common/base-listing-query.class.ts");
class LanguagesQuery extends base_listing_query_class_1.BaseListingQuery {
    constructor(config, queryService) {
        super(config, queryService);
        this.config = config;
        this.queryService = queryService;
        /**
         * Endpoint
         */
        this.endpoint = 'languages';
        this._queryConfig = {};
    }
    /**
     * Limits the number of taxonomies returned by query
     * @param limit Number of taxonomies to load
     */
    limitParameter(limit) {
        this.parameters.push(new models_1.Parameters.LimitParameter(limit));
        return this;
    }
    /**
     * Skips the selected number of taxonomies
     * @param skip Number of taxonomies to skip
     */
    skipParameter(skip) {
        this.parameters.push(new models_1.Parameters.SkipParameter(skip));
        return this;
    }
    toPromise() {
        var _a;
        return this.queryService.getLanguages(this.getUrl(), (_a = this._queryConfig) !== null && _a !== void 0 ? _a : {});
    }
    getUrl() {
        const action = '/' + this.endpoint;
        return super.resolveUrlInternal(action);
    }
    /**
     * Used to configure query
     * @param queryConfig Query configuration
     */
    queryConfig(queryConfig) {
        this._queryConfig = queryConfig;
        return this;
    }
    map(json) {
        return this.queryService.mappingService.listLanguagesResponse(json);
    }
    allResponseFactory(items, responses) {
        return {
            items: items,
            responses: responses
        };
    }
}
exports.LanguagesQuery = LanguagesQuery;


/***/ }),

/***/ "./lib/query/sync/initialize-sync-query.class.ts":
/*!*******************************************************!*\
  !*** ./lib/query/sync/initialize-sync-query.class.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InitializeSyncQuery = void 0;
const models_1 = __webpack_require__(/*! ../../models */ "./lib/models/index.ts");
const base_query_class_1 = __webpack_require__(/*! ../common/base-query.class */ "./lib/query/common/base-query.class.ts");
class InitializeSyncQuery extends base_query_class_1.BaseQuery {
    constructor(config, queryService) {
        super(config, queryService);
        this.config = config;
        this.queryService = queryService;
        this.endpoint = 'sync/init';
        this._queryConfig = {};
    }
    /**
     * Gets only item of given type
     * @param type Codename of type to get
     */
    type(type) {
        this.parameters.push(new models_1.Filters.TypeFilter(type));
        return this;
    }
    /**
     * Gets only item from given collection
     * @param collection Codename of collection to get
     */
    collection(collection) {
        this.parameters.push(new models_1.Filters.CollectionFilter(collection));
        return this;
    }
    /**
     * Language codename
     * @param languageCodename Codename of the language
     */
    languageParameter(languageCodename) {
        this.parameters.push(new models_1.Parameters.LanguageParameter(languageCodename));
        return this;
    }
    toPromise() {
        var _a;
        return this.queryService.initializeSync(this.getUrl(), (_a = this._queryConfig) !== null && _a !== void 0 ? _a : {});
    }
    getUrl() {
        const action = '/' + this.endpoint;
        return super.resolveUrlInternal(action);
    }
    /**
     * Used to configure query
     * @param queryConfig Query configuration
     */
    queryConfig(queryConfig) {
        this._queryConfig = queryConfig;
        return this;
    }
    map(json) {
        return this.queryService.mappingService.initializeContentSync(json);
    }
}
exports.InitializeSyncQuery = InitializeSyncQuery;


/***/ }),

/***/ "./lib/query/sync/sync-changes-query.class.ts":
/*!****************************************************!*\
  !*** ./lib/query/sync/sync-changes-query.class.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyncChangesQuery = void 0;
const base_listing_query_class_1 = __webpack_require__(/*! ../common/base-listing-query.class */ "./lib/query/common/base-listing-query.class.ts");
class SyncChangesQuery extends base_listing_query_class_1.BaseListingQuery {
    constructor(config, queryService) {
        super(config, queryService);
        this.config = config;
        this.queryService = queryService;
        this._queryConfig = {};
        this.action = '/sync';
    }
    toPromise() {
        var _a;
        return this.queryService.syncChanges(this.getUrl(), (_a = this._queryConfig) !== null && _a !== void 0 ? _a : {});
    }
    getUrl() {
        return super.resolveUrlInternal(this.action);
    }
    /**
     * Used to configure query
     * @param queryConfig Query configuration
     */
    queryConfig(queryConfig) {
        this._queryConfig = queryConfig;
        return this;
    }
    map(json) {
        return this.queryService.mappingService.syncChanges(json);
    }
    allResponseFactory(items, responses) {
        return {
            items: items,
            responses: responses
        };
    }
}
exports.SyncChangesQuery = SyncChangesQuery;


/***/ }),

/***/ "./lib/query/taxonomy/taxonomies-query.class.ts":
/*!******************************************************!*\
  !*** ./lib/query/taxonomy/taxonomies-query.class.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TaxonomiesQuery = void 0;
const models_1 = __webpack_require__(/*! ../../models */ "./lib/models/index.ts");
const base_listing_query_class_1 = __webpack_require__(/*! ../common/base-listing-query.class */ "./lib/query/common/base-listing-query.class.ts");
class TaxonomiesQuery extends base_listing_query_class_1.BaseListingQuery {
    constructor(config, queryService) {
        super(config, queryService);
        this.config = config;
        this.queryService = queryService;
        /**
         * Taxonomies endpoint URL action
         */
        this.taxonomiesEndpoint = 'taxonomies';
        this._queryConfig = {};
    }
    /**
     * Limits the number of taxonomies returned by query
     * @param limit Number of taxonomies to load
     */
    limitParameter(limit) {
        this.parameters.push(new models_1.Parameters.LimitParameter(limit));
        return this;
    }
    /**
     * Skips the selected number of taxonomies
     * @param skip Number of taxonomies to skip
     */
    skipParameter(skip) {
        this.parameters.push(new models_1.Parameters.SkipParameter(skip));
        return this;
    }
    toPromise() {
        var _a;
        return this.queryService.getTaxonomies(this.getUrl(), (_a = this._queryConfig) !== null && _a !== void 0 ? _a : {});
    }
    getUrl() {
        const action = '/' + this.taxonomiesEndpoint;
        return super.resolveUrlInternal(action);
    }
    map(json) {
        return this.queryService.mappingService.listTaxonomiesResponse(json);
    }
    allResponseFactory(items, responses) {
        return {
            items: items,
            responses: responses
        };
    }
}
exports.TaxonomiesQuery = TaxonomiesQuery;


/***/ }),

/***/ "./lib/query/taxonomy/taxonomy-query.class.ts":
/*!****************************************************!*\
  !*** ./lib/query/taxonomy/taxonomy-query.class.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TaxonomyQuery = void 0;
const base_query_class_1 = __webpack_require__(/*! ../common/base-query.class */ "./lib/query/common/base-query.class.ts");
class TaxonomyQuery extends base_query_class_1.BaseQuery {
    constructor(config, queryService, taxonomyCodename) {
        super(config, queryService);
        this.config = config;
        this.queryService = queryService;
        this.taxonomyCodename = taxonomyCodename;
        /**
         * Taxonomies endpoint URL action
         */
        this.taxonomiesEndpoint = 'taxonomies';
        this._queryConfig = {};
        if (!taxonomyCodename) {
            throw Error(`Cannot create taxonomy query without codename of the taxonomy`);
        }
    }
    toPromise() {
        var _a;
        return this.queryService.getTaxonomy(this.getUrl(), (_a = this._queryConfig) !== null && _a !== void 0 ? _a : {});
    }
    getUrl() {
        const action = '/' + this.taxonomiesEndpoint + '/' + this.taxonomyCodename;
        return super.resolveUrlInternal(action);
    }
    map(json) {
        return this.queryService.mappingService.viewTaxonomyResponse(json);
    }
}
exports.TaxonomyQuery = TaxonomyQuery;


/***/ }),

/***/ "./lib/query/type/multiple-type-query.class.ts":
/*!*****************************************************!*\
  !*** ./lib/query/type/multiple-type-query.class.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MultipleTypeQuery = void 0;
const models_1 = __webpack_require__(/*! ../../models */ "./lib/models/index.ts");
const base_listing_query_class_1 = __webpack_require__(/*! ../common/base-listing-query.class */ "./lib/query/common/base-listing-query.class.ts");
class MultipleTypeQuery extends base_listing_query_class_1.BaseListingQuery {
    constructor(config, queryService) {
        super(config, queryService);
        this.config = config;
        this.queryService = queryService;
        this._queryConfig = {};
    }
    /**
     * Used to limit the number of elements returned by query.
     * @param elementCodenames Array of element codenames to fetch
     */
    elementsParameter(elementCodenames) {
        this.parameters.push(new models_1.Parameters.ElementsParameter(elementCodenames));
        return this;
    }
    /**
     * Limits the number of taxonomies returned by query
     * @param limit Number of taxonomies to load
     */
    limitParameter(limit) {
        this.parameters.push(new models_1.Parameters.LimitParameter(limit));
        return this;
    }
    /**
     * Skips the selected number of taxonomies
     * @param skip Number of taxonomies to skip
     */
    skipParameter(skip) {
        this.parameters.push(new models_1.Parameters.SkipParameter(skip));
        return this;
    }
    toPromise() {
        var _a;
        return this.queryService.getMultipleTypes(this.getUrl(), (_a = this._queryConfig) !== null && _a !== void 0 ? _a : {});
    }
    getUrl() {
        const action = '/types';
        return super.resolveUrlInternal(action);
    }
    map(json) {
        return this.queryService.mappingService.listContentTypesResponse(json);
    }
    allResponseFactory(items, responses) {
        return {
            items: items,
            responses: responses
        };
    }
}
exports.MultipleTypeQuery = MultipleTypeQuery;


/***/ }),

/***/ "./lib/query/type/single-type-query.class.ts":
/*!***************************************************!*\
  !*** ./lib/query/type/single-type-query.class.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SingleTypeQuery = void 0;
const base_query_class_1 = __webpack_require__(/*! ../common/base-query.class */ "./lib/query/common/base-query.class.ts");
class SingleTypeQuery extends base_query_class_1.BaseQuery {
    constructor(config, queryService, typeCodename) {
        super(config, queryService);
        this.config = config;
        this.queryService = queryService;
        this.typeCodename = typeCodename;
        this._queryConfig = {};
        if (!typeCodename) {
            throw Error(`Cannot create type query without the codename of the type`);
        }
    }
    toPromise() {
        var _a;
        return this.queryService.getSingleType(this.getUrl(), (_a = this._queryConfig) !== null && _a !== void 0 ? _a : {});
    }
    getUrl() {
        const action = '/types/' + this.typeCodename;
        return super.resolveUrlInternal(action);
    }
    map(json) {
        return this.queryService.mappingService.viewContentTypeResponse(json);
    }
}
exports.SingleTypeQuery = SingleTypeQuery;


/***/ }),

/***/ "./lib/resolvers/index.ts":
/*!********************************!*\
  !*** ./lib/resolvers/index.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./rich-text/rich-text-resolver.models */ "./lib/resolvers/rich-text/rich-text-resolver.models.ts"), exports);
__exportStar(__webpack_require__(/*! ./property-name/camel-case-property-name-resolver.class */ "./lib/resolvers/property-name/camel-case-property-name-resolver.class.ts"), exports);
__exportStar(__webpack_require__(/*! ./property-name/pascal-case-property-name-resolver.class */ "./lib/resolvers/property-name/pascal-case-property-name-resolver.class.ts"), exports);
__exportStar(__webpack_require__(/*! ./property-name/snake-case-property-name-resolver.class */ "./lib/resolvers/property-name/snake-case-property-name-resolver.class.ts"), exports);
__exportStar(__webpack_require__(/*! ./rich-text/sync/rich-text-html-resolver */ "./lib/resolvers/rich-text/sync/rich-text-html-resolver.ts"), exports);
__exportStar(__webpack_require__(/*! ./rich-text/sync/rich-text-object-resolver */ "./lib/resolvers/rich-text/sync/rich-text-object-resolver.ts"), exports);
__exportStar(__webpack_require__(/*! ./rich-text/sync/rich-text-json-resolver */ "./lib/resolvers/rich-text/sync/rich-text-json-resolver.ts"), exports);
__exportStar(__webpack_require__(/*! ./rich-text/async/async-rich-text-html-resolver */ "./lib/resolvers/rich-text/async/async-rich-text-html-resolver.ts"), exports);


/***/ }),

/***/ "./lib/resolvers/property-name/camel-case-property-name-resolver.class.ts":
/*!********************************************************************************!*\
  !*** ./lib/resolvers/property-name/camel-case-property-name-resolver.class.ts ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.camelCasePropertyNameResolver = void 0;
const utilities_1 = __webpack_require__(/*! ../../utilities */ "./lib/utilities/index.ts");
const camelCasePropertyNameResolver = (contentType, element) => {
    return utilities_1.textHelper.addUnderscoreWhenStarsWithNumber(utilities_1.textHelper.removeZeroWidthCharacters(camelize(element)));
};
exports.camelCasePropertyNameResolver = camelCasePropertyNameResolver;
function camelize(str) {
    str = str.replace(utilities_1.textHelper.getPropertyNameRegex(), (_, c) => (c ? c.toUpperCase() : ''));
    return str.substring(0, 1).toLowerCase() + str.substring(1);
}


/***/ }),

/***/ "./lib/resolvers/property-name/pascal-case-property-name-resolver.class.ts":
/*!*********************************************************************************!*\
  !*** ./lib/resolvers/property-name/pascal-case-property-name-resolver.class.ts ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.pascalCasePropertyNameResolver = void 0;
const utilities_1 = __webpack_require__(/*! ../../utilities */ "./lib/utilities/index.ts");
const pascalCasePropertyNameResolver = (contentType, element) => {
    return utilities_1.textHelper.addUnderscoreWhenStarsWithNumber(utilities_1.textHelper.removeZeroWidthCharacters(camelize(element)));
};
exports.pascalCasePropertyNameResolver = pascalCasePropertyNameResolver;
function camelize(str) {
    str = str.replace(utilities_1.textHelper.getPropertyNameRegex(), (_, c) => (c ? c.toUpperCase() : ''));
    return str.substring(0, 1).toUpperCase() + str.substring(1);
}


/***/ }),

/***/ "./lib/resolvers/property-name/snake-case-property-name-resolver.class.ts":
/*!********************************************************************************!*\
  !*** ./lib/resolvers/property-name/snake-case-property-name-resolver.class.ts ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.snakeCasePropertyNameResolver = void 0;
const utilities_1 = __webpack_require__(/*! ../../utilities */ "./lib/utilities/index.ts");
const snakeCasePropertyNameResolver = (contentType, element) => {
    return utilities_1.textHelper
        .addUnderscoreWhenStarsWithNumber(utilities_1.textHelper.removeZeroWidthCharacters(toSnakeCase(element)))
        .toLowerCase();
};
exports.snakeCasePropertyNameResolver = snakeCasePropertyNameResolver;
function toSnakeCase(str) {
    str = str.replace(utilities_1.textHelper.getPropertyNameRegex(), (_, c) => '_' + (c ? c.toLowerCase() : ''));
    return removeEndUnderscore(removeStartUnderscore(str));
}
function removeStartUnderscore(str) {
    if (!str.startsWith('_')) {
        return str;
    }
    return str.substring(1);
}
function removeEndUnderscore(str) {
    if (!str.endsWith('_')) {
        return str;
    }
    return str.slice(0, -1);
}


/***/ }),

/***/ "./lib/resolvers/rich-text/async/async-rich-text-html-resolver.ts":
/*!************************************************************************!*\
  !*** ./lib/resolvers/rich-text/async/async-rich-text-html-resolver.ts ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createAsyncRichTextHtmlResolver = exports.AsyncRichTextHtmlResolver = void 0;
const parser_1 = __webpack_require__(/*! ../../../parser */ "./lib/parser/index.ts");
const base_async_rich_text_resolver_1 = __webpack_require__(/*! ../base/base-async-rich-text-resolver */ "./lib/resolvers/rich-text/base/base-async-rich-text-resolver.ts");
class AsyncRichTextHtmlResolver extends base_async_rich_text_resolver_1.BaseAsyncRichTextResolver {
    constructor(parser) {
        super(parser_1.asyncBrowserParser, parser);
    }
    resolveRichTextAsync(input) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.resolveRichTextInternalAsync(input.element.value, input);
        });
    }
    resolveRichTextInternalAsync(html, input) {
        const _super = Object.create(null, {
            getAsyncParser: { get: () => super.getAsyncParser }
        });
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const parsedResult = yield _super.getAsyncParser.call(this).parseAsync(html, input.element, {
                elementResolverAsync: (element) => __awaiter(this, void 0, void 0, function* () { }),
                contentItemResolverAsync: (element, itemCodename, linkedItemIndex, linkedItem) => __awaiter(this, void 0, void 0, function* () {
                    var _b;
                    const parentElement = element.parentElement;
                    if (parentElement) {
                        const resolvedItemHtml = input.contentItemResolverAsync
                            ? (_b = (yield input.contentItemResolverAsync(itemCodename, linkedItem)).contentItemHtml) !== null && _b !== void 0 ? _b : ''
                            : '';
                        // resursively resolve HTML
                        const innerHtml = (yield this.resolveRichTextInternalAsync(resolvedItemHtml, input)).html;
                        // set resolved html
                        if (input.preserveResolvedObjectTags === true) {
                            element.setInnerHtml(innerHtml);
                        }
                        else {
                            element.setOuterHtml(innerHtml);
                        }
                        // set resolved attribute
                        element.setAttribute(parser_1.parserHelper.sdkResolvedAttributeName, '1');
                    }
                }),
                genericElementResolverAsync: (element) => __awaiter(this, void 0, void 0, function* () {
                    // do nothing to generic elements
                }),
                imageResolverAsync: (element, imageId, image) => __awaiter(this, void 0, void 0, function* () {
                    // get image result
                    const imageResult = input.imageResolverAsync
                        ? yield input.imageResolverAsync(imageId, image)
                        : undefined;
                    // html has priority over url resolver
                    if (imageResult === null || imageResult === void 0 ? void 0 : imageResult.imageHtml) {
                        // replace link html
                        element.setOuterHtml(imageResult.imageHtml);
                    }
                    else if (imageResult === null || imageResult === void 0 ? void 0 : imageResult.imageUrl) {
                        // set link url only
                        element.setAttribute(parser_1.parserConfiguration.imageElementData.srcAttribute, imageResult.imageUrl);
                    }
                }),
                urlResolverAsync: (element, linkId, linkText, link) => __awaiter(this, void 0, void 0, function* () {
                    if (input.urlResolverAsync) {
                        const urlResult = yield input.urlResolverAsync(linkId, linkText, link);
                        // html has priority over url resolver
                        if (urlResult === null || urlResult === void 0 ? void 0 : urlResult.linkHtml) {
                            // replace link html
                            element.setOuterHtml(urlResult.linkHtml);
                        }
                        else if (urlResult === null || urlResult === void 0 ? void 0 : urlResult.linkUrl) {
                            // set link url only
                            element.setAttribute('href', urlResult.linkUrl);
                        }
                    }
                })
            }, (_a = input.linkedItems) !== null && _a !== void 0 ? _a : []);
            return {
                componentCodenames: parsedResult.componentCodenames,
                linkedItemCodenames: parsedResult.linkedItemCodenames,
                html: parsedResult.result
            };
        });
    }
}
exports.AsyncRichTextHtmlResolver = AsyncRichTextHtmlResolver;
const createAsyncRichTextHtmlResolver = (parser) => new AsyncRichTextHtmlResolver(parser);
exports.createAsyncRichTextHtmlResolver = createAsyncRichTextHtmlResolver;


/***/ }),

/***/ "./lib/resolvers/rich-text/base/base-async-rich-text-resolver.ts":
/*!***********************************************************************!*\
  !*** ./lib/resolvers/rich-text/base/base-async-rich-text-resolver.ts ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseAsyncRichTextResolver = void 0;
class BaseAsyncRichTextResolver {
    constructor(defaultParser, parser) {
        this.defaultParser = defaultParser;
        this.parser = parser;
    }
    getAsyncParser() {
        if (this.parser) {
            return this.parser;
        }
        return this.defaultParser;
    }
}
exports.BaseAsyncRichTextResolver = BaseAsyncRichTextResolver;


/***/ }),

/***/ "./lib/resolvers/rich-text/base/base-rich-text-resolver.ts":
/*!*****************************************************************!*\
  !*** ./lib/resolvers/rich-text/base/base-rich-text-resolver.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseRichTextResolver = void 0;
class BaseRichTextResolver {
    constructor(defaultParser, parser) {
        this.defaultParser = defaultParser;
        this.parser = parser;
    }
    getParser() {
        if (this.parser) {
            return this.parser;
        }
        return this.defaultParser;
    }
}
exports.BaseRichTextResolver = BaseRichTextResolver;


/***/ }),

/***/ "./lib/resolvers/rich-text/rich-text-resolver.models.ts":
/*!**************************************************************!*\
  !*** ./lib/resolvers/rich-text/rich-text-resolver.models.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./lib/resolvers/rich-text/sync/rich-text-html-resolver.ts":
/*!*****************************************************************!*\
  !*** ./lib/resolvers/rich-text/sync/rich-text-html-resolver.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createRichTextHtmlResolver = exports.RichTextHtmlResolver = void 0;
const parser_1 = __webpack_require__(/*! ../../../parser */ "./lib/parser/index.ts");
const base_rich_text_resolver_1 = __webpack_require__(/*! ../base/base-rich-text-resolver */ "./lib/resolvers/rich-text/base/base-rich-text-resolver.ts");
class RichTextHtmlResolver extends base_rich_text_resolver_1.BaseRichTextResolver {
    constructor(parser) {
        super(parser_1.browserParser, parser);
    }
    resolveRichText(input) {
        return this.resolveRichTextInternal(input.element.value, input);
    }
    resolveRichTextInternal(html, input) {
        var _a;
        const parsedResult = super.getParser().parse(html, input.element, {
            elementResolver: (element) => { },
            contentItemResolver: (element, itemCodename, linkedItemIndex, linkedItem) => {
                var _a;
                const parentElement = element.parentElement;
                if (parentElement) {
                    const resolvedItemHtml = input.contentItemResolver
                        ? (_a = input.contentItemResolver(itemCodename, linkedItem).contentItemHtml) !== null && _a !== void 0 ? _a : ''
                        : '';
                    // resursively resolve HTML
                    const innerHtml = this.resolveRichTextInternal(resolvedItemHtml, input).html;
                    // set resolved html
                    if (input.preserveResolvedObjectTags === true) {
                        element.setInnerHtml(innerHtml);
                    }
                    else {
                        element.setOuterHtml(innerHtml);
                    }
                    // set resolved attribute
                    element.setAttribute(parser_1.parserHelper.sdkResolvedAttributeName, '1');
                }
            },
            genericElementResolver: (element) => {
                // do nothing to generic elements
            },
            imageResolver: (element, imageId, image) => {
                // get image result
                const imageResult = input.imageResolver ? input.imageResolver(imageId, image) : undefined;
                // html has priority over url resolver
                if (imageResult === null || imageResult === void 0 ? void 0 : imageResult.imageHtml) {
                    // replace link html
                    element.setOuterHtml(imageResult.imageHtml);
                }
                else if (imageResult === null || imageResult === void 0 ? void 0 : imageResult.imageUrl) {
                    // set link url only
                    element.setAttribute(parser_1.parserConfiguration.imageElementData.srcAttribute, imageResult.imageUrl);
                }
            },
            urlResolver: (element, linkId, linkText, link) => {
                if (input.urlResolver) {
                    const urlResult = input.urlResolver(linkId, linkText, link);
                    // html has priority over url resolver
                    if (urlResult === null || urlResult === void 0 ? void 0 : urlResult.linkHtml) {
                        // replace link html
                        element.setOuterHtml(urlResult.linkHtml);
                    }
                    else if (urlResult === null || urlResult === void 0 ? void 0 : urlResult.linkUrl) {
                        // set link url only
                        element.setAttribute('href', urlResult.linkUrl);
                    }
                }
            }
        }, (_a = input.linkedItems) !== null && _a !== void 0 ? _a : []);
        return {
            componentCodenames: parsedResult.componentCodenames,
            linkedItemCodenames: parsedResult.linkedItemCodenames,
            html: parsedResult.result
        };
    }
}
exports.RichTextHtmlResolver = RichTextHtmlResolver;
const createRichTextHtmlResolver = (parser) => new RichTextHtmlResolver(parser);
exports.createRichTextHtmlResolver = createRichTextHtmlResolver;


/***/ }),

/***/ "./lib/resolvers/rich-text/sync/rich-text-json-resolver.ts":
/*!*****************************************************************!*\
  !*** ./lib/resolvers/rich-text/sync/rich-text-json-resolver.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createRichTextJsonResolver = exports.RichTextJsonResolver = void 0;
const parser_1 = __webpack_require__(/*! ../../../parser */ "./lib/parser/index.ts");
const base_rich_text_resolver_1 = __webpack_require__(/*! ../base/base-rich-text-resolver */ "./lib/resolvers/rich-text/base/base-rich-text-resolver.ts");
const rich_text_object_resolver_1 = __webpack_require__(/*! ./rich-text-object-resolver */ "./lib/resolvers/rich-text/sync/rich-text-object-resolver.ts");
class RichTextJsonResolver extends base_rich_text_resolver_1.BaseRichTextResolver {
    constructor(parser) {
        super(parser_1.browserParser, parser);
    }
    resolveRichText(input) {
        const objectResult = (0, rich_text_object_resolver_1.createRichTextObjectResolver)(this.getParser()).resolveRichText(input).data;
        return {
            json: JSON.stringify(objectResult)
        };
    }
}
exports.RichTextJsonResolver = RichTextJsonResolver;
const createRichTextJsonResolver = (parser) => new RichTextJsonResolver(parser);
exports.createRichTextJsonResolver = createRichTextJsonResolver;


/***/ }),

/***/ "./lib/resolvers/rich-text/sync/rich-text-object-resolver.ts":
/*!*******************************************************************!*\
  !*** ./lib/resolvers/rich-text/sync/rich-text-object-resolver.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createRichTextObjectResolver = exports.RichTextObjectResolver = void 0;
const parser_1 = __webpack_require__(/*! ../../../parser */ "./lib/parser/index.ts");
const utilities_1 = __webpack_require__(/*! ../../../utilities */ "./lib/utilities/index.ts");
const base_rich_text_resolver_1 = __webpack_require__(/*! ../base/base-rich-text-resolver */ "./lib/resolvers/rich-text/base/base-rich-text-resolver.ts");
class RichTextObjectResolver extends base_rich_text_resolver_1.BaseRichTextResolver {
    constructor(parser) {
        super(parser_1.browserParser, parser);
        this.sdkIdAttributeName = 'sdk-elem-id';
        this.rootId = 'root';
        this.defaultWrapTag = 'div';
    }
    resolveRichText(input) {
        var _a;
        const result = this.resolveRichTextInternal(input.element.value, input, {
            type: 'root',
            attributes: [],
            children: [],
            data: {},
            tag: (_a = input.wrapperTag) !== null && _a !== void 0 ? _a : this.defaultWrapTag,
            _sdkElemId: this.rootId
        });
        if (input.cleanSdkIds === true) {
            this.cleanSdkIds(result);
        }
        return {
            data: result
        };
    }
    resolveRichTextInternal(html, input, result) {
        var _a;
        super.getParser().parse(html, input.element, {
            elementResolver: (element) => {
                // generate guid for each element
                element.setAttribute(this.sdkIdAttributeName, utilities_1.guidHelper.genereateGuid());
            },
            contentItemResolver: (element, itemCodename, linkedItemIndex, linkedItem) => {
                const data = {
                    codename: itemCodename,
                    item: linkedItem
                };
                const parentSdkId = this.getSdkIdFromElement(element.parentElement);
                const parentItem = this.findItemWithSdkId(parentSdkId, result);
                if (parentItem) {
                    parentItem.children.push({
                        type: 'linkedItem',
                        attributes: this.getAttributes(element),
                        tag: element.tag.toLowerCase(),
                        data: data,
                        children: [],
                        _sdkElemId: this.getSdkIdFromElement(element)
                    });
                }
            },
            genericElementResolver: (element) => {
                var _a, _b;
                const data = {
                    text: (_a = element.text) !== null && _a !== void 0 ? _a : '',
                    html: (_b = element.html) !== null && _b !== void 0 ? _b : ''
                };
                const parentSdkId = this.getSdkIdFromElement(element.parentElement);
                const parentItem = this.findItemWithSdkId(parentSdkId, result);
                if (parentItem) {
                    parentItem.children.push({
                        type: 'htmlElement',
                        attributes: this.getAttributes(element),
                        tag: element.tag.toLowerCase(),
                        data: data,
                        children: [],
                        _sdkElemId: this.getSdkIdFromElement(element)
                    });
                }
            },
            imageResolver: (element, imageId, image) => {
                const data = {
                    imageId: imageId,
                    image: image
                };
                const parentSdkId = this.getSdkIdFromElement(element.parentElement);
                const parentItem = this.findItemWithSdkId(parentSdkId, result);
                if (parentItem) {
                    parentItem.children.push({
                        type: 'image',
                        attributes: this.getAttributes(element),
                        tag: element.tag.toLowerCase(),
                        data: data,
                        children: [],
                        _sdkElemId: this.getSdkIdFromElement(element)
                    });
                }
            },
            urlResolver: (element, linkId, linkText, link) => {
                const data = {
                    linkId: linkId,
                    linkText: linkText,
                    link: link
                };
                const parentSdkId = this.getSdkIdFromElement(element.parentElement);
                const parentItem = this.findItemWithSdkId(parentSdkId, result);
                if (parentItem) {
                    parentItem.children.push({
                        type: 'link',
                        attributes: this.getAttributes(element),
                        tag: element.tag.toLowerCase(),
                        data: data,
                        children: [],
                        _sdkElemId: this.getSdkIdFromElement(element)
                    });
                }
            }
        }, (_a = input.linkedItems) !== null && _a !== void 0 ? _a : []);
        return result;
    }
    findItemWithSdkId(sdkId, item) {
        if (item._sdkElemId === sdkId) {
            return item;
        }
        for (const child of item.children) {
            const foundItem = this.findItemWithSdkId(sdkId, child);
            if (foundItem) {
                return foundItem;
            }
        }
        return undefined;
    }
    getAttributes(element) {
        var _a;
        return (_a = element === null || element === void 0 ? void 0 : element.attributes) !== null && _a !== void 0 ? _a : [];
    }
    getSdkIdFromElement(element) {
        var _a, _b;
        if (!element) {
            return this.rootId;
        }
        const value = (_b = (_a = element.attributes.find((m) => m.name === this.sdkIdAttributeName)) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : this.rootId;
        return value;
    }
    cleanSdkIds(item) {
        item.attributes = item.attributes.filter((m) => m.name !== this.sdkIdAttributeName);
        item._sdkElemId = '';
        for (const child of item.children) {
            this.cleanSdkIds(child);
        }
    }
}
exports.RichTextObjectResolver = RichTextObjectResolver;
const createRichTextObjectResolver = (parser) => new RichTextObjectResolver(parser);
exports.createRichTextObjectResolver = createRichTextObjectResolver;


/***/ }),

/***/ "./lib/sdk-info.generated.ts":
/*!***********************************!*\
  !*** ./lib/sdk-info.generated.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sdkInfo = void 0;
exports.sdkInfo = {
    host: 'npmjs.com',
    version: '12.4.2',
    name: '@kontent-ai/delivery-sdk'
};


/***/ }),

/***/ "./lib/services/base-delivery-query.service.ts":
/*!*****************************************************!*\
  !*** ./lib/services/base-delivery-query.service.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseDeliveryQueryService = void 0;
const core_sdk_1 = __webpack_require__(/*! @kontent-ai/core-sdk */ "./node_modules/@kontent-ai/core-sdk/dist/es6/index.js");
const models_1 = __webpack_require__(/*! ../models */ "./lib/models/index.ts");
class BaseDeliveryQueryService {
    constructor(
    /**
     * Delivery client configuration
     */
    config, 
    /**
     * Http service for fetching data
     */
    httpService, 
    /**
     * Information about the SDK
     */
    sdkInfo, 
    /**
     * Mapping service
     */
    mappingService) {
        this.config = config;
        this.httpService = httpService;
        this.sdkInfo = sdkInfo;
        this.mappingService = mappingService;
        /**
         * Default base Url to Kontent.ai Delivery API
         */
        this.defaultBaseDeliveryApiUrl = 'https://deliver.kontent.ai';
        /**
         * Default preview url to Kontent.ai Delivery API
         */
        this.defaultPreviewDeliveryApiUrl = 'https://preview-deliver.kontent.ai';
    }
    /**
     * Gets url based on the action, query configuration and options (parameters)
     * @param action Action (= url part) that will be hit
     * @param queryConfig Query configuration
     * @param options Query options
     */
    getUrl(action, queryConfig, options) {
        if (!this.config.proxy || !this.config.proxy.advancedProxyUrlResolver) {
            return core_sdk_1.urlHelper.addOptionsToUrl(this.getBaseUrl(queryConfig) + action, options);
        }
        return this.config.proxy.advancedProxyUrlResolver({
            queryParameters: options ? options : [],
            queryString: core_sdk_1.urlHelper.addOptionsToUrl('', options),
            action: action,
            domain: this.getDomain(queryConfig),
            queryConfig: queryConfig,
            projectId: this.config.projectId
        });
    }
    /**
     * Gets proper set of headers for given request.
     * @param queryConfig Query configuration
     * @param additionalHeaders Custom headers
     */
    getHeaders(queryConfig, additionalHeaders) {
        const headers = [];
        if (additionalHeaders) {
            headers.push(...additionalHeaders);
        }
        // add SDK Id header for monitoring SDK usage
        headers.push(this.getSdkIdHeader());
        // add headers from global config
        if (this.config.globalHeaders) {
            headers.push(...this.config.globalHeaders(queryConfig));
        }
        // add query / global headers from query config
        headers.push(...this.getQueryHeaders(queryConfig));
        if (this.isPreviewModeEnabled(queryConfig) && this.isSecuredModeEnabled(queryConfig)) {
            throw Error(`Preview & secured modes cannot be used at the same time.`);
        }
        // add preview header is required
        if (this.isPreviewModeEnabled(queryConfig) && this.config.previewApiKey) {
            headers.push(this.getAuthorizationHeader(this.config.previewApiKey));
        }
        // add secured mode header is required
        if (this.isSecuredModeEnabled(queryConfig) && this.config.secureApiKey) {
            headers.push(this.getAuthorizationHeader(this.config.secureApiKey));
        }
        // add 'X-KC-Wait-For-Loading-New-Content' header if required
        if (this.shouldAddWaitForLoadingNewContentHeader(queryConfig)) {
            headers.push({
                header: models_1.waitForLoadingNewContentHeader,
                value: 'true'
            });
        }
        return headers;
    }
    /**
     * Http POST response
     * @param url Url of request
     * @param queryConfig Query config configuration
     */
    postResponseAsync(url, body, queryConfig, serviceConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!queryConfig) {
                queryConfig = {};
            }
            if (!serviceConfig) {
                serviceConfig = {};
            }
            try {
                return yield this.httpService.postAsync({
                    url: url,
                    body: body
                }, {
                    cancelToken: queryConfig === null || queryConfig === void 0 ? void 0 : queryConfig.cancelToken,
                    responseType: 'json',
                    retryStrategy: this.config.retryStrategy,
                    headers: this.getHeaders(queryConfig, serviceConfig.headers ? serviceConfig.headers : [])
                });
            }
            catch (error) {
                throw this.mapDeliveryError(error);
            }
        });
    }
    /**
     * Http GET response
     * @param url Url of request
     * @param queryConfig Query config configuration
     */
    getResponseAsync(url, queryConfig, serviceConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!queryConfig) {
                queryConfig = {};
            }
            if (!serviceConfig) {
                serviceConfig = {};
            }
            try {
                return yield this.httpService.getAsync({
                    url: url
                }, {
                    cancelToken: queryConfig === null || queryConfig === void 0 ? void 0 : queryConfig.cancelToken,
                    responseType: 'json',
                    retryStrategy: this.config.retryStrategy,
                    headers: this.getHeaders(queryConfig, serviceConfig.headers ? serviceConfig.headers : [])
                });
            }
            catch (error) {
                throw this.mapDeliveryError(error);
            }
        });
    }
    /**
     * Gets base URL of the request including the project Id
     * @param queryConfig Query configuration
     */
    getBaseUrl(queryConfig) {
        return this.getDomain(queryConfig) + '/' + this.config.projectId;
    }
    mapNetworkResponse(data, response) {
        return {
            data: data,
            response: response,
            hasStaleContent: this.getHasStaleContent(response.headers),
            xContinuationToken: this.getContinuationToken(response.headers)
        };
    }
    /**
     * Indicates if current query should use preview mode
     * @param queryConfig Query configuration
     */
    isPreviewModeEnabled(queryConfig) {
        if (queryConfig.usePreviewMode !== undefined) {
            return queryConfig.usePreviewMode;
        }
        if (!this.config.defaultQueryConfig) {
            return false;
        }
        if (this.config.defaultQueryConfig.usePreviewMode === true) {
            return true;
        }
        return false;
    }
    getQueryHeaders(queryConfig) {
        var _a;
        if (queryConfig.customHeaders) {
            return queryConfig.customHeaders;
        }
        if ((_a = this.config.defaultQueryConfig) === null || _a === void 0 ? void 0 : _a.customHeaders) {
            return this.config.defaultQueryConfig.customHeaders;
        }
        return [];
    }
    shouldAddWaitForLoadingNewContentHeader(queryConfig) {
        if (queryConfig.waitForLoadingNewContent !== undefined) {
            return queryConfig.waitForLoadingNewContent;
        }
        if (!this.config.defaultQueryConfig) {
            return false;
        }
        if (this.config.defaultQueryConfig.waitForLoadingNewContent === true) {
            return true;
        }
        return false;
    }
    /**
     * Indicates if current query should use secured mode
     * @param queryConfig Query configuration
     */
    isSecuredModeEnabled(queryConfig) {
        if (queryConfig.useSecuredMode !== undefined) {
            return queryConfig.useSecuredMode;
        }
        if (!this.config.defaultQueryConfig) {
            return false;
        }
        if (this.config.defaultQueryConfig.useSecuredMode === true) {
            return true;
        }
        return false;
    }
    /**
     * Gets preview or standard URL based on client and query configuration
     * @param queryConfig Query configuration
     */
    getDomain(queryConfig) {
        if (this.isPreviewModeEnabled(queryConfig)) {
            if (!this.config.previewApiKey) {
                throw Error(`Preview API key is not configured.`);
            }
            // check custom preview url
            if (this.config.proxy && this.config.proxy.basePreviewUrl) {
                return this.config.proxy.basePreviewUrl;
            }
            // use default preview url
            return this.defaultPreviewDeliveryApiUrl;
        }
        // check custom base url
        if (this.config.proxy && this.config.proxy.baseUrl) {
            return this.config.proxy.baseUrl;
        }
        return this.defaultBaseDeliveryApiUrl;
    }
    /**
     * Gets authorization header. This is used for 'preview' functionality
     */
    getAuthorizationHeader(key) {
        if (!key) {
            throw Error(`Cannot get authorization header because key is invalid`);
        }
        // authorization header required for preview mode
        return {
            header: 'authorization',
            value: `bearer ${key}`
        };
    }
    /**
     * Header identifying SDK type & version for internal purposes of Kontent.ai
     */
    getSdkIdHeader() {
        return {
            header: models_1.sdkVersionHeader,
            value: `${this.sdkInfo.host};${this.sdkInfo.name};${this.sdkInfo.version}`
        };
    }
    mapDeliveryError(error) {
        var _a;
        let axiosError;
        if (error.error) {
            axiosError = error.error;
        }
        else {
            axiosError = error;
        }
        if (!axiosError || !axiosError.isAxiosError) {
            return error;
        }
        const deliveryErrorData = (_a = axiosError.response) === null || _a === void 0 ? void 0 : _a.data;
        if (!deliveryErrorData || !deliveryErrorData.error_code) {
            return error;
        }
        return new models_1.DeliveryError({
            errorCode: deliveryErrorData.error_code,
            message: deliveryErrorData.message,
            specificCode: deliveryErrorData.specific_code,
            requestId: deliveryErrorData.request_id
        });
    }
    getHasStaleContent(headers) {
        const hasStaleContentHeader = headers.find((m) => m.header.toLowerCase() === models_1.staleContentHeaderName.toLowerCase());
        if (hasStaleContentHeader) {
            if (hasStaleContentHeader.value.toString() === '1') {
                return true;
            }
        }
        return false;
    }
    getContinuationToken(headers) {
        const header = headers.find((m) => m.header.toLowerCase() === models_1.continuationTokenHeaderName.toLowerCase());
        return header ? header.value : undefined;
    }
}
exports.BaseDeliveryQueryService = BaseDeliveryQueryService;


/***/ }),

/***/ "./lib/services/delivery-query.service.ts":
/*!************************************************!*\
  !*** ./lib/services/delivery-query.service.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.QueryService = void 0;
const base_delivery_query_service_1 = __webpack_require__(/*! ./base-delivery-query.service */ "./lib/services/base-delivery-query.service.ts");
class QueryService extends base_delivery_query_service_1.BaseDeliveryQueryService {
    constructor(config, httpService, sdkInfo, mappingService) {
        super(config, httpService, sdkInfo, mappingService);
    }
    /**
     * Gets single item from given url
     * @param url Url used to get single item
     * @param queryConfig Query configuration
     */
    getSingleItemAsync(url, queryConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getResponseAsync(url, queryConfig);
            return this.mapNetworkResponse(this.mappingService.viewContentItemResponse(response.data), response);
        });
    }
    /**
     * Gets single feed response. Might not contain all items in your project.
     * @param url Url
     * @param queryConfig Query configuration
     */
    getItemsFeed(url, queryConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getResponseAsync(url, queryConfig);
            return this.mapNetworkResponse(this.mappingService.itemsFeedResponse(response.data), response);
        });
    }
    /**
     * Gets multiple items from given url
     * @param url Url used to get multiple items
     * @param queryConfig Query configuration
     */
    getMultipleItems(url, queryConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getResponseAsync(url, queryConfig);
            return this.mapNetworkResponse(this.mappingService.listContentItemsResponse(response.data), response);
        });
    }
    /**
     * Gets single content type from given url
     * @param url Url used to get single type
     * @param queryConfig Query configuration
     */
    getSingleType(url, queryConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getResponseAsync(url, queryConfig);
            return this.mapNetworkResponse(this.mappingService.viewContentTypeResponse(response.data), response);
        });
    }
    /**
     * Gets multiple content types from given url
     * @param url Url used to get multiple types
     * @param queryConfig Query configuration
     */
    getMultipleTypes(url, queryConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getResponseAsync(url, queryConfig);
            return this.mapNetworkResponse(this.mappingService.listContentTypesResponse(response.data), response);
        });
    }
    /**
     * Initializes synchronization of changes in content items based on the specified parameters. After the initialization,
     * you'll get an X-Continuation token in the response.
     * Use the token to synchronize changes in the content items matching the initialization criteria.
     * @param url Url
     * @param queryConfig Query configuration
     */
    initializeSync(url, queryConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.postResponseAsync(url, {}, queryConfig);
            return this.mapNetworkResponse(this.mappingService.initializeContentSync(response.data), response);
        });
    }
    /**
     * Retrieve a list of delta updates to recently changed content items in the specified project.
     * The types of items you get is determined by the X-Continuation token you use.
     * @param url Url used to get multiple types
     * @param queryConfig Query configuration
     */
    syncChanges(url, queryConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getResponseAsync(url, queryConfig);
            return this.mapNetworkResponse(this.mappingService.syncChanges(response.data), response);
        });
    }
    /**
     * Gets languages
     * @param url Url
     * @param queryConfig Query configuration
     */
    getLanguages(url, queryConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getResponseAsync(url, queryConfig);
            return this.mapNetworkResponse(this.mappingService.listLanguagesResponse(response.data), response);
        });
    }
    /**
     * Gets single taxonomy from given url
     * @param url Url used to get single taxonomy
     * @param queryConfig Query configuration
     */
    getTaxonomy(url, queryConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getResponseAsync(url, queryConfig);
            return this.mapNetworkResponse(this.mappingService.viewTaxonomyResponse(response.data), response);
        });
    }
    /**
     * Gets multiple taxonomies from given url
     * @param url Url used to get multiple taxonomies
     * @param queryConfig Query configuration
     */
    getTaxonomies(url, queryConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getResponseAsync(url, queryConfig);
            return this.mapNetworkResponse(this.mappingService.listTaxonomiesResponse(response.data), response);
        });
    }
    /**
     * Gets single content type element from given url
     * @param url Url used to get single content type element
     * @param queryConfig Query configuration
     */
    getElementAsync(url, queryConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getResponseAsync(url, queryConfig);
            return this.mapNetworkResponse(this.mappingService.viewContentTypeElementResponse(response.data), response);
        });
    }
    getListAllResponse(data) {
        return __awaiter(this, void 0, void 0, function* () {
            const responses = yield this.getListAllResponseInternalAsync({
                page: data.page,
                resolvedResponses: [],
                getResponse: data.getResponse,
                nextPageUrl: undefined,
                continuationToken: undefined,
                listQueryConfig: data.listQueryConfig
            });
            return data.allResponseFactory(responses.reduce((prev, current) => {
                prev.push(...current.data.items);
                return prev;
            }, []), responses);
        });
    }
    getListAllResponseInternalAsync(data) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            if ((_a = data.listQueryConfig) === null || _a === void 0 ? void 0 : _a.pages) {
                if (data.page > data.listQueryConfig.pages) {
                    // page limit reached, return result
                    return data.resolvedResponses;
                }
            }
            const response = yield data.getResponse(data.nextPageUrl, data.continuationToken);
            if ((_b = data.listQueryConfig) === null || _b === void 0 ? void 0 : _b.delayBetweenRequests) {
                yield this.sleep(data.listQueryConfig.delayBetweenRequests);
            }
            data.resolvedResponses.push(response);
            if ((_c = data.listQueryConfig) === null || _c === void 0 ? void 0 : _c.responseFetched) {
                data.listQueryConfig.responseFetched(response, data.nextPageUrl, data.continuationToken);
            }
            const nextPage = (_d = response.data.pagination) === null || _d === void 0 ? void 0 : _d.nextPage;
            const continuationToken = response.xContinuationToken;
            if (nextPage || continuationToken) {
                // recursively fetch next page data
                return yield this.getListAllResponseInternalAsync({
                    page: data.page + 1,
                    nextPageUrl: nextPage,
                    continuationToken: continuationToken,
                    listQueryConfig: data.listQueryConfig,
                    getResponse: data.getResponse,
                    resolvedResponses: data.resolvedResponses
                });
            }
            return data.resolvedResponses;
        });
    }
    sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
    }
}
exports.QueryService = QueryService;


/***/ }),

/***/ "./lib/services/index.ts":
/*!*******************************!*\
  !*** ./lib/services/index.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./delivery-query.service */ "./lib/services/delivery-query.service.ts"), exports);
__exportStar(__webpack_require__(/*! ./mapping.service */ "./lib/services/mapping.service.ts"), exports);


/***/ }),

/***/ "./lib/services/mapping.service.ts":
/*!*****************************************!*\
  !*** ./lib/services/mapping.service.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MappingService = void 0;
const mappers_1 = __webpack_require__(/*! ../mappers */ "./lib/mappers/index.ts");
class MappingService {
    constructor(config) {
        this.config = config;
        this.typeMapper = new mappers_1.TypeMapper();
        this.languageMapper = new mappers_1.LanguageMapper();
        this.itemMapper = new mappers_1.ItemMapper(config);
        this.taxonomyMapper = new mappers_1.TaxonomyMapper();
        this.genericElementMapper = new mappers_1.GenericElementMapper();
        this.syncMapper = new mappers_1.SyncMapper();
    }
    /**
     * Gets response for list of languages
     * @param data Response data
     */
    listLanguagesResponse(data) {
        return {
            items: this.languageMapper.mapMultipleLanguages(data),
            pagination: this.mapPagination(data.pagination)
        };
    }
    /**
     * Gets response for getting a multiple type
     * @param data Response data
     */
    listContentTypesResponse(data) {
        return {
            items: this.typeMapper.mapMultipleTypes(data),
            pagination: this.mapPagination(data.pagination)
        };
    }
    /**
     * Gets response for single type
     * @param data Response data
     * @param options Options
     */
    viewContentTypeResponse(data) {
        return {
            type: this.typeMapper.mapSingleType(data)
        };
    }
    itemsFeedResponse(data) {
        const itemsResult = this.itemMapper.mapItems({
            linkedItems: Object.values(data.modular_content),
            mainItems: data.items
        });
        return {
            items: itemsResult.items,
            linkedItems: itemsResult.linkedItems
        };
    }
    /**
     * Gets response for getting single item
     * @param data Response data
     * @param queryConfig Query configuration
     */
    viewContentItemResponse(data) {
        const itemResult = this.itemMapper.mapSingleItemFromResponse(data);
        return {
            item: itemResult.item,
            linkedItems: itemResult.linkedItems
        };
    }
    /**
     * Gets response for getting multiple items
     * @param data Response data
     * @param queryConfig Query configuration
     */
    listContentItemsResponse(data) {
        const itemsResult = this.itemMapper.mapMultipleItemsFromResponse(data);
        return {
            items: itemsResult.items,
            pagination: this.mapPagination(data.pagination),
            linkedItems: itemsResult.linkedItems
        };
    }
    /**
     * Gets response for getting single taxonomy item
     * @param data Response data
     */
    viewTaxonomyResponse(data) {
        return {
            taxonomy: this.taxonomyMapper.mapTaxonomy(data.system, data.terms)
        };
    }
    /**
     * Gets response for getting multiples taxonomies
     * @param data Response data
     */
    listTaxonomiesResponse(data) {
        return {
            items: this.taxonomyMapper.mapTaxonomies(data.taxonomies),
            pagination: this.mapPagination(data.pagination)
        };
    }
    /**
     * Gets response for getting single content type element
     * @param data Response data
     */
    viewContentTypeElementResponse(data) {
        return {
            element: this.genericElementMapper.mapElement(data)
        };
    }
    initializeContentSync(data) {
        return {
            items: data.items.map((m) => this.syncMapper.mapContentItemDelta(m))
        };
    }
    syncChanges(data) {
        return {
            items: data.items.map((m) => this.syncMapper.mapContentItemDelta(m))
        };
    }
    mapPagination(paginationContract) {
        var _a;
        return {
            skip: paginationContract.skip,
            count: paginationContract.count,
            limit: paginationContract.limit,
            nextPage: paginationContract.next_page,
            totalCount: (_a = paginationContract.total_count) !== null && _a !== void 0 ? _a : null
        };
    }
}
exports.MappingService = MappingService;


/***/ }),

/***/ "./lib/utilities/delivery-url.helper.ts":
/*!**********************************************!*\
  !*** ./lib/utilities/delivery-url.helper.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deliveryUrlHelper = exports.DeliveryUrlHelper = void 0;
const urlParse = __webpack_require__(/*! url-parse */ "./node_modules/url-parse/index.js");
class DeliveryUrlHelper {
    replaceAssetDomain(originalAssetUrl, customDomain) {
        const urlPath = this.getUrlPathname(originalAssetUrl);
        return `${customDomain}${urlPath}`;
    }
    getUrlPathname(url) {
        const parsedUrl = urlParse(url);
        return parsedUrl.pathname;
    }
}
exports.DeliveryUrlHelper = DeliveryUrlHelper;
exports.deliveryUrlHelper = new DeliveryUrlHelper();


/***/ }),

/***/ "./lib/utilities/guid.helper.ts":
/*!**************************************!*\
  !*** ./lib/utilities/guid.helper.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.guidHelper = exports.GuidHelper = void 0;
const uuid_1 = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/commonjs-browser/index.js");
class GuidHelper {
    genereateGuid() {
        return (0, uuid_1.v4)();
    }
}
exports.GuidHelper = GuidHelper;
exports.guidHelper = new GuidHelper();


/***/ }),

/***/ "./lib/utilities/index.ts":
/*!********************************!*\
  !*** ./lib/utilities/index.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./linked-items.helper */ "./lib/utilities/linked-items.helper.ts"), exports);
__exportStar(__webpack_require__(/*! ./guid.helper */ "./lib/utilities/guid.helper.ts"), exports);
__exportStar(__webpack_require__(/*! ./delivery-url.helper */ "./lib/utilities/delivery-url.helper.ts"), exports);
__exportStar(__webpack_require__(/*! ./text-helper */ "./lib/utilities/text-helper.ts"), exports);


/***/ }),

/***/ "./lib/utilities/linked-items.helper.ts":
/*!**********************************************!*\
  !*** ./lib/utilities/linked-items.helper.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.linkedItemsHelper = exports.LinkedItemsHelper = void 0;
class LinkedItemsHelper {
    convertLinkedItemsToArray(linkedItems) {
        const linkedItemsArray = [];
        for (const linkedItemKey of Object.keys(linkedItems)) {
            linkedItemsArray.push(linkedItems[linkedItemKey]);
        }
        return linkedItemsArray;
    }
}
exports.LinkedItemsHelper = LinkedItemsHelper;
exports.linkedItemsHelper = new LinkedItemsHelper();


/***/ }),

/***/ "./lib/utilities/text-helper.ts":
/*!**************************************!*\
  !*** ./lib/utilities/text-helper.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.textHelper = exports.TextHelper = void 0;
class TextHelper {
    getPropertyNameRegex() {
        return /[;,\/\&\(\)\?\-\=\'\"\\\xa7\!\%\:\_\s.]+(.)?/g;
    }
    removeZeroWidthCharacters(str) {
        return str.replace(/[\u200B-\u200D\uFEFF]/g, '');
    }
    addUnderscoreWhenStarsWithNumber(str) {
        if (this.startsWithNumber(str)) {
            return `_${str}`;
        }
        return str;
    }
    startsWithNumber(str) {
        if (str.match(/^\d/)) {
            return true;
        }
        return false;
    }
}
exports.TextHelper = TextHelper;
exports.textHelper = new TextHelper();


/***/ }),

/***/ "./node_modules/url-parse/index.js":
/*!*****************************************!*\
  !*** ./node_modules/url-parse/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var required = __webpack_require__(/*! requires-port */ "./node_modules/requires-port/index.js")
  , qs = __webpack_require__(/*! querystringify */ "./node_modules/querystringify/index.js")
  , controlOrWhitespace = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/
  , CRHTLF = /[\n\r\t]/g
  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//
  , port = /:\d+$/
  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i
  , windowsDriveLetter = /^[a-zA-Z]:/;

/**
 * Remove control characters and whitespace from the beginning of a string.
 *
 * @param {Object|String} str String to trim.
 * @returns {String} A new string representing `str` stripped of control
 *     characters and whitespace from its beginning.
 * @public
 */
function trimLeft(str) {
  return (str ? str : '').toString().replace(controlOrWhitespace, '');
}

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  function sanitize(address, url) {     // Sanitize what is left of the address
    return isSpecial(url.protocol) ? address.replace(/\\/g, '/') : address;
  },
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d*)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 };

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @public
 */
function lolcation(loc) {
  var globalVar;

  if (typeof window !== 'undefined') globalVar = window;
  else if (typeof __webpack_require__.g !== 'undefined') globalVar = __webpack_require__.g;
  else if (typeof self !== 'undefined') globalVar = self;
  else globalVar = {};

  var location = globalVar.location || {};
  loc = loc || location;

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new Url(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
}

/**
 * Check whether a protocol scheme is special.
 *
 * @param {String} The protocol scheme of the URL
 * @return {Boolean} `true` if the protocol scheme is special, else `false`
 * @private
 */
function isSpecial(scheme) {
  return (
    scheme === 'file:' ||
    scheme === 'ftp:' ||
    scheme === 'http:' ||
    scheme === 'https:' ||
    scheme === 'ws:' ||
    scheme === 'wss:'
  );
}

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @param {Object} location
 * @return {ProtocolExtract} Extracted information.
 * @private
 */
function extractProtocol(address, location) {
  address = trimLeft(address);
  address = address.replace(CRHTLF, '');
  location = location || {};

  var match = protocolre.exec(address);
  var protocol = match[1] ? match[1].toLowerCase() : '';
  var forwardSlashes = !!match[2];
  var otherSlashes = !!match[3];
  var slashesCount = 0;
  var rest;

  if (forwardSlashes) {
    if (otherSlashes) {
      rest = match[2] + match[3] + match[4];
      slashesCount = match[2].length + match[3].length;
    } else {
      rest = match[2] + match[4];
      slashesCount = match[2].length;
    }
  } else {
    if (otherSlashes) {
      rest = match[3] + match[4];
      slashesCount = match[3].length;
    } else {
      rest = match[4]
    }
  }

  if (protocol === 'file:') {
    if (slashesCount >= 2) {
      rest = rest.slice(2);
    }
  } else if (isSpecial(protocol)) {
    rest = match[4];
  } else if (protocol) {
    if (forwardSlashes) {
      rest = rest.slice(2);
    }
  } else if (slashesCount >= 2 && isSpecial(location.protocol)) {
    rest = match[4];
  }

  return {
    protocol: protocol,
    slashes: forwardSlashes || isSpecial(protocol),
    slashesCount: slashesCount,
    rest: rest
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @private
 */
function resolve(relative, base) {
  if (relative === '') return base;

  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * It is worth noting that we should not use `URL` as class name to prevent
 * clashes with the global URL instance that got introduced in browsers.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} [location] Location defaults for relative paths.
 * @param {Boolean|Function} [parser] Parser for the query string.
 * @private
 */
function Url(address, location, parser) {
  address = trimLeft(address);
  address = address.replace(CRHTLF, '');

  if (!(this instanceof Url)) {
    return new Url(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = qs.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '', location);
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (
    extracted.protocol === 'file:' && (
      extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) ||
    (!extracted.slashes &&
      (extracted.protocol ||
        extracted.slashesCount < 2 ||
        !isSpecial(url.protocol)))
  ) {
    instructions[3] = [/(.*)/, 'pathname'];
  }

  for (; i < instructions.length; i++) {
    instruction = instructions[i];

    if (typeof instruction === 'function') {
      address = instruction(address, url);
      continue;
    }

    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      index = parse === '@'
        ? address.lastIndexOf(parse)
        : address.indexOf(parse);

      if (~index) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // Default to a / for pathname if none exists. This normalizes the URL
  // to always have a /
  //
  if (url.pathname.charAt(0) !== '/' && isSpecial(url.protocol)) {
    url.pathname = '/' + url.pathname;
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';

  if (url.auth) {
    index = url.auth.indexOf(':');

    if (~index) {
      url.username = url.auth.slice(0, index);
      url.username = encodeURIComponent(decodeURIComponent(url.username));

      url.password = url.auth.slice(index + 1);
      url.password = encodeURIComponent(decodeURIComponent(url.password))
    } else {
      url.username = encodeURIComponent(decodeURIComponent(url.auth));
    }

    url.auth = url.password ? url.username +':'+ url.password : url.username;
  }

  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL} URL instance for chaining.
 * @public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (port.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
    case 'hash':
      if (value) {
        var char = part === 'pathname' ? '/' : '#';
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;

    case 'username':
    case 'password':
      url[part] = encodeURIComponent(value);
      break;

    case 'auth':
      var index = value.indexOf(':');

      if (~index) {
        url.username = value.slice(0, index);
        url.username = encodeURIComponent(decodeURIComponent(url.username));

        url.password = value.slice(index + 1);
        url.password = encodeURIComponent(decodeURIComponent(url.password));
      } else {
        url.username = encodeURIComponent(decodeURIComponent(value));
      }
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.auth = url.password ? url.username +':'+ url.password : url.username;

  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
}

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String} Compiled version of the URL.
 * @public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , host = url.host
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result =
    protocol +
    ((url.protocol && url.slashes) || isSpecial(url.protocol) ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  } else if (url.password) {
    result += ':'+ url.password;
    result += '@';
  } else if (
    url.protocol !== 'file:' &&
    isSpecial(url.protocol) &&
    !host &&
    url.pathname !== '/'
  ) {
    //
    // Add back the empty userinfo, otherwise the original invalid URL
    // might be transformed into a valid one with `url.pathname` as host.
    //
    result += '@';
  }

  //
  // Trailing colon is removed from `url.host` when it is parsed. If it still
  // ends with a colon, then add back the trailing colon that was removed. This
  // prevents an invalid URL from being transformed into a valid one.
  //
  if (host[host.length - 1] === ':' || (port.test(url.hostname) && !url.port)) {
    host += ':';
  }

  result += host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

Url.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.trimLeft = trimLeft;
Url.qs = qs;

module.exports = Url;


/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "NIL", ({
  enumerable: true,
  get: function get() {
    return _nil.default;
  }
}));
Object.defineProperty(exports, "parse", ({
  enumerable: true,
  get: function get() {
    return _parse.default;
  }
}));
Object.defineProperty(exports, "stringify", ({
  enumerable: true,
  get: function get() {
    return _stringify.default;
  }
}));
Object.defineProperty(exports, "v1", ({
  enumerable: true,
  get: function get() {
    return _v.default;
  }
}));
Object.defineProperty(exports, "v3", ({
  enumerable: true,
  get: function get() {
    return _v2.default;
  }
}));
Object.defineProperty(exports, "v4", ({
  enumerable: true,
  get: function get() {
    return _v3.default;
  }
}));
Object.defineProperty(exports, "v5", ({
  enumerable: true,
  get: function get() {
    return _v4.default;
  }
}));
Object.defineProperty(exports, "validate", ({
  enumerable: true,
  get: function get() {
    return _validate.default;
  }
}));
Object.defineProperty(exports, "version", ({
  enumerable: true,
  get: function get() {
    return _version.default;
  }
}));

var _v = _interopRequireDefault(__webpack_require__(/*! ./v1.js */ "./node_modules/uuid/dist/commonjs-browser/v1.js"));

var _v2 = _interopRequireDefault(__webpack_require__(/*! ./v3.js */ "./node_modules/uuid/dist/commonjs-browser/v3.js"));

var _v3 = _interopRequireDefault(__webpack_require__(/*! ./v4.js */ "./node_modules/uuid/dist/commonjs-browser/v4.js"));

var _v4 = _interopRequireDefault(__webpack_require__(/*! ./v5.js */ "./node_modules/uuid/dist/commonjs-browser/v5.js"));

var _nil = _interopRequireDefault(__webpack_require__(/*! ./nil.js */ "./node_modules/uuid/dist/commonjs-browser/nil.js"));

var _version = _interopRequireDefault(__webpack_require__(/*! ./version.js */ "./node_modules/uuid/dist/commonjs-browser/version.js"));

var _validate = _interopRequireDefault(__webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/commonjs-browser/validate.js"));

var _stringify = _interopRequireDefault(__webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/commonjs-browser/stringify.js"));

var _parse = _interopRequireDefault(__webpack_require__(/*! ./parse.js */ "./node_modules/uuid/dist/commonjs-browser/parse.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/md5.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/md5.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

/*
 * Browser-compatible JavaScript MD5
 *
 * Modification of JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */
function md5(bytes) {
  if (typeof bytes === 'string') {
    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = new Uint8Array(msg.length);

    for (let i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }

  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
/*
 * Convert an array of little-endian words to an array of bytes
 */


function md5ToHexEncodedArray(input) {
  const output = [];
  const length32 = input.length * 32;
  const hexTab = '0123456789abcdef';

  for (let i = 0; i < length32; i += 8) {
    const x = input[i >> 5] >>> i % 32 & 0xff;
    const hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
    output.push(hex);
  }

  return output;
}
/**
 * Calculate output length with padding and bit length
 */


function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */


function wordsToMd5(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << len % 32;
  x[getOutputLength(len) - 1] = len;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;

  for (let i = 0; i < x.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }

  return [a, b, c, d];
}
/*
 * Convert an array bytes to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */


function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }

  const length8 = input.length * 8;
  const output = new Uint32Array(getOutputLength(length8));

  for (let i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
  }

  return output;
}
/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */


function safeAdd(x, y) {
  const lsw = (x & 0xffff) + (y & 0xffff);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xffff;
}
/*
 * Bitwise rotate a 32-bit number to the left.
 */


function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
/*
 * These functions implement the four basic operations the algorithm uses.
 */


function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}

function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}

function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}

function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}

function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}

var _default = md5;
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/native.js":
/*!***********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/native.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var _default = {
  randomUUID
};
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/nil.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/nil.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _default = '00000000-0000-0000-0000-000000000000';
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/parse.js":
/*!**********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/parse.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _validate = _interopRequireDefault(__webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/commonjs-browser/validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parse(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  let v;
  const arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

var _default = parse;
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/regex.js":
/*!**********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/regex.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/rng.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/rng.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = rng;
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
let getRandomValues;
const rnds8 = new Uint8Array(16);

function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/sha1.js":
/*!*********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/sha1.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;

    case 1:
      return x ^ y ^ z;

    case 2:
      return x & y ^ x & z ^ y & z;

    case 3:
      return x ^ y ^ z;
  }
}

function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}

function sha1(bytes) {
  const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
  const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

  if (typeof bytes === 'string') {
    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = [];

    for (let i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    // Convert Array-like to Array
    bytes = Array.prototype.slice.call(bytes);
  }

  bytes.push(0x80);
  const l = bytes.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);

  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);

    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }

    M[i] = arr;
  }

  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;

  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);

    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }

    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }

    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];

    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }

    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }

  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
}

var _default = sha1;
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/stringify.js":
/*!**************************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/stringify.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
exports.unsafeStringify = unsafeStringify;

var _validate = _interopRequireDefault(__webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/commonjs-browser/validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).slice(1));
}

function unsafeStringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

function stringify(arr, offset = 0) {
  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

var _default = stringify;
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/v1.js":
/*!*******************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/v1.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _rng = _interopRequireDefault(__webpack_require__(/*! ./rng.js */ "./node_modules/uuid/dist/commonjs-browser/rng.js"));

var _stringify = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/commonjs-browser/stringify.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
let _nodeId;

let _clockseq; // Previous uuid creation time


let _lastMSecs = 0;
let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || _rng.default)();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || (0, _stringify.unsafeStringify)(b);
}

var _default = v1;
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/v3.js":
/*!*******************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/v3.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _v = _interopRequireDefault(__webpack_require__(/*! ./v35.js */ "./node_modules/uuid/dist/commonjs-browser/v35.js"));

var _md = _interopRequireDefault(__webpack_require__(/*! ./md5.js */ "./node_modules/uuid/dist/commonjs-browser/md5.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v3 = (0, _v.default)('v3', 0x30, _md.default);
var _default = v3;
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/v35.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/v35.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.URL = exports.DNS = void 0;
exports["default"] = v35;

var _stringify = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/commonjs-browser/stringify.js");

var _parse = _interopRequireDefault(__webpack_require__(/*! ./parse.js */ "./node_modules/uuid/dist/commonjs-browser/parse.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  const bytes = [];

  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
exports.DNS = DNS;
const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
exports.URL = URL;

function v35(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;

    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = (0, _parse.default)(namespace);
    }

    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return (0, _stringify.unsafeStringify)(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/v4.js":
/*!*******************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/v4.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _native = _interopRequireDefault(__webpack_require__(/*! ./native.js */ "./node_modules/uuid/dist/commonjs-browser/native.js"));

var _rng = _interopRequireDefault(__webpack_require__(/*! ./rng.js */ "./node_modules/uuid/dist/commonjs-browser/rng.js"));

var _stringify = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/commonjs-browser/stringify.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function v4(options, buf, offset) {
  if (_native.default.randomUUID && !buf && !options) {
    return _native.default.randomUUID();
  }

  options = options || {};

  const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`


  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return (0, _stringify.unsafeStringify)(rnds);
}

var _default = v4;
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/v5.js":
/*!*******************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/v5.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _v = _interopRequireDefault(__webpack_require__(/*! ./v35.js */ "./node_modules/uuid/dist/commonjs-browser/v35.js"));

var _sha = _interopRequireDefault(__webpack_require__(/*! ./sha1.js */ "./node_modules/uuid/dist/commonjs-browser/sha1.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v5 = (0, _v.default)('v5', 0x50, _sha.default);
var _default = v5;
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/validate.js":
/*!*************************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/validate.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _regex = _interopRequireDefault(__webpack_require__(/*! ./regex.js */ "./node_modules/uuid/dist/commonjs-browser/regex.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function validate(uuid) {
  return typeof uuid === 'string' && _regex.default.test(uuid);
}

var _default = validate;
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/version.js":
/*!************************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/version.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _validate = _interopRequireDefault(__webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/commonjs-browser/validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function version(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.slice(14, 15), 16);
}

var _default = version;
exports["default"] = _default;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./lib/index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=kontent-delivery.umd.js.map